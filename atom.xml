<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Chouqin & Laoqi</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2012-11-11T23:21:34+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Qiping Li</name>
   <email>liqiping1991@gmail.com</email>
 </author>

 
 <entry>
   <title>中文编码闲谈</title>
   <link href="http://username.github.com/python/2012/11/11/chinese-encoding"/>
   <updated>2012-11-11T00:00:00+08:00</updated>
   <id>http://username.github.com/python/2012/11/11/chinese-encoding</id>
   <content type="html">&lt;p&gt;作为一个天朝的程序员，总是会在编程的时候与中文打交道。一开始对于编码不是很熟悉，也没有弄明白它里面的原理，
在处理中文的时候总是会遇到各种各样的问题，特别是在用python处理中文的时候，
所以特地花时间研究了一下中文编码，并通过python来熟悉一些概念。&lt;/p&gt;

&lt;p&gt;废话不多说，先上干货，&lt;a href=&quot;http://www.searchtb.com/2012/04/chinese_encode.html&quot;&gt;中文编码杂谈&lt;/a&gt;，这篇文章是淘宝
搜索技术团队写的，深入浅出，基本上将中文编码的各个方面讲得十分细致，而且十分通俗易懂。我很难讲得比这篇文章
更好了，我主要从几个侧面来阐述一下我对于中文编码的理解。&lt;/p&gt;

&lt;h2&gt;中文编码是什么&lt;/h2&gt;

&lt;p&gt;中文编码其实就是将中文转化为二进制比特串的过程，而不同的编码方式会把同一个中文字符转化为不同的二进制表示，
比如“中”这个字，通过utf-8编码会转化为二进制E4B8AD，而在计算中，所有的数据都是通过二进制保存，这样我们就可以
通过二进制E4B8AD来保存“中”字，然后我们如果需要读取保存的这个字，我们首先需要知道编码方式是utf-8，然后就能将
E4B8AD转化为“中”。&lt;/p&gt;

&lt;h2&gt;python的中文处理&lt;/h2&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello_world&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;hello world!&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;



</content>
 </entry>
 
 <entry>
   <title>最近的总结与感悟</title>
   <link href="http://username.github.com/Feelings/2012/10/27/feeling"/>
   <updated>2012-10-27T00:00:00+08:00</updated>
   <id>http://username.github.com/Feelings/2012/10/27/feeling</id>
   <content type="html">

&lt;h2&gt;来由&lt;/h2&gt;

&lt;p&gt;这段时间真的很忙，忙得都没时间好好看书，好好写博客。&lt;/p&gt;

&lt;p&gt;每天都要上班，还要忙着保研的各种事情，有时还在保研和直接工作中纠结，
导致一有一点空闲时间，就什么事情也没想干了。&lt;/p&gt;

&lt;p&gt;还好，现在这些事情也终于告一段落，也不用再去纠结什么了，终于可以静下心来
去做自己喜欢做的事，踏踏实实地学习某些东西了。&lt;/p&gt;

&lt;p&gt;但是总结一番还是有点必要的，不然这些日子的纠结不是白费了吗。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h2&gt;我为什么选择读研&lt;/h2&gt;

&lt;p&gt;其实这个星期的前两天还在纠结当中，可是就好像砸中牛顿的那个苹果一样，
某种东西突然在我的头脑中闪现，让我顿悟，这个东西就是：梦想。&lt;/p&gt;

&lt;p&gt;梦想，别扯淡了，这年头谁还看中这个。&lt;/p&gt;

&lt;p&gt;我看中，我认为一个人一旦失去了梦想，活着也就没有什么意思了。
能支持一个人不断向前，不断超越自己的动力，也只有梦想。&lt;/p&gt;

&lt;p&gt;我的梦想又是什么呢？很简单，在自己所在的领域有所建树，然后把
这个领域的技术能够向前推动一点，哪怕只是一点。而这个简单的梦想，
仍需要很多的努力才能实现，我的希望是能够一直在这个努力的过程中，
不要因为其他的东西的干扰而偏离了梦想。&lt;/p&gt;

&lt;p&gt;而我差点因为微软的offer而偏离，极高的工资，舒适的工作环境，做的却
不是自己喜欢做的事。我明白，相对于其他在微软实习或者工作的人来说，
我还是相差太远。他们都是计算机竞赛的佼佼者，身上顶着各种光环，在计算机方面的积累比我
多了好几年，单就他们做过的题，我可能一辈子都来不及做完。我现在的学的东西也不是很扎实，
什么都知道一点，可都不精，如果再在微软待下去，或许就会沉浸在这种安逸的生活中，无法再
往一个更高的方向发展了。对于正值奋斗年华的我来说，过分的安乐真的不是什么好事。
而且在微软做的不是我喜欢做的事，要想突破感觉还是太难了。&lt;/p&gt;

&lt;p&gt;那为什么不把工作当成白天的事，然后空闲时间去做自己喜欢做的事呢？我也考虑过这个问题，
最后发现这很难成功。因为这样每天最多能花两个小时在自己喜欢做的事情上面，而同时可能会
有各种事情打乱你的计划，想对于正式工作的每天八小时，这其中的差距可想而知。在互联网这样一个
高速发展的行业，低速成长是很容易被淘汰的，这样的过程，最多持续半年，我想就会终止，然后渐渐地
开始沦落为毫无激情的上班族。能够通过用这种方式坚持的，至少在中国我还没有听说过。&lt;/p&gt;

&lt;p&gt;所以，我还需要很多的积累，扎实地磨练技术，同时更加开阔自己的眼界，而这些，通过研究生的三年，能够做到。&lt;/p&gt;

&lt;h2&gt;对自己目前的定位&lt;/h2&gt;

&lt;p&gt;总的来说，就是接触了很多的东西，但没有什么谈得上精通。&lt;/p&gt;

&lt;h3&gt;语言&lt;/h3&gt;

&lt;p&gt;语言确实用过很多，上过两个学期的C++课程，用C++写了数据结构的作业和USACO上的一些题，对于C++，应该算是最
熟悉的语言之一了吧，它的语法，还有很多相关的概念，包括虚函数，多态等等，都已经掌握了。可是不能算精通，对于它
的掌握仅仅局限于课堂，没用过STL,看过的书也就只有《C++ Primer》一本（教材除外），也没用它开发过大型的项目，对于
C++这样一门庞大的语言来说，这些还远远不够。&lt;/p&gt;

&lt;p&gt;关于C，也就用它写过操作系统的大作业，对于Unix环境下的C编程有一定的了解，现在如果要用C写一个大型的项目的话，
应该也没有什么问题，但如果要称得上是精通，还需要大量的练习才行。&lt;/p&gt;

&lt;p&gt;关于php，python，现在在上班的时候用得比较多，也正在处于一个水平稳步上升的阶段，我想经过一年的积累，这两门语言应该
是能够相当熟练，甚至是精通。&lt;/p&gt;

&lt;p&gt;关于javascript，CSS(如果它也算语言的话)，基本的语法也都知道，可是积累还远远不够，特别是javascript，这门上手容易，精通确
很难的语言，因为工作主要偏后端，所以熟练程度还是不够。&lt;/p&gt;

&lt;p&gt;关于C#，用它做过几个项目，用了WPF,ASP.NET，感觉C#这门语言还是比较容易上手的，写起代码来也很方便，配合上VS这个强大的IDE，
开发还是挺快的。我对它的了解还比较基础，至于它的反射，Delegation，Event等等东西，只是清楚概念，没有实际使用过。&lt;/p&gt;

&lt;p&gt;另外，我上过程序设计语言这门课程，在这门课程中，我接触了大量的语言，也用这些语言写过程序。
使用过Java，Perl,Scheme,Haskell,Prolog这些语言。值得一提的是，scheme和prolog我都写过好几个程序，
虽然这两门语言都比较奇怪，但是写程序时确实能够开阔思路，还是两门比较有趣的语言，我比较喜欢。&lt;/p&gt;

&lt;p&gt;对于“语言之争”，我没有特别的看法，我也没有特别的感觉说只用某一门语言或者只喜欢某一种语言。我觉得在不同的领域，
不同的场景，可能有些语言比另外一些语言要适合一些，比如说开发系统级别的应用程序，对执行效率要求比较高，这样，
C或者C++可能要适合一些，又比如一些做一些自动事情的脚本，可能python或者php用起来更加方便一些。每个语言都有它的
优点，对于语言我还是没有什么挑剔。&lt;/p&gt;

&lt;h3&gt;专业基础知识&lt;/h3&gt;

&lt;p&gt;对于专业知识，大部分都只限于课程，都是通过教材来了解，虽然这些教材都是国外的经典教材，
可是我觉得我们利用的还是太少了，大家都平时没怎么认真学习，然后到了考试，老师会给出几个
重点，然后大家根据这几个重点复习，应付考试而已。这些经典的教材，又岂是短短的这几天能够
掌握的？而我也不过是把这几天的时间分配到了整个学期而已，也就是说，我会跟着老师的上课进度，
把这些教材看一遍，看得有多深入，浅尝辄止罢了，粗粗地过完内容，然后总结一下了事。掌握得不是很扎实，
导致成绩也不是很好。专业基础课中，掌握得比较扎实的应该算操作系统和编译原理了吧，因为这两门课都做过
课程设计，多多少少需要了解一些东西。另外数据库也算把教材看得比较透彻的一门课，虽然考试成绩不咋的。&lt;/p&gt;

&lt;h3&gt;算法&lt;/h3&gt;

&lt;p&gt;只是知道常见几种算法:贪心法，分治法，动态规划。数据结构了解了：数，堆，哈希表，图，以及图的遍历，
最小生成树，最短路径。对于算法来说，和那些比较厉害的人的差距就在于：练习不够。别人能够做到各种算法
烂熟于胸，看到某类问题立刻想到相关的算法，因为什么，就是练习了那么多，一个问题做上10几遍，怎么能不熟。
所以在算法方面，我还得勤加练习，不然只能维持在现在的，看上去都会的水平。说现在找工作只看算法有点绝对，但
只要算法好想找任何工作是绝对没有问题的，各种经历告诉我这个观点的正确性。另外，在此提醒自己，《算法导论》
一定要坚持看完了，给自己下定一个决心吧。&lt;/p&gt;

&lt;h3&gt;技术之外&lt;/h3&gt;

&lt;p&gt;首先是表达能力有待增强，把自己清楚的东西讲到让别人也清楚这确实是一种艺术。写博客是一种很好的锻炼自己表达
能力的手段，所以我会经常把自己对技术的感悟通过写博客的方式表达出来，同时也分享了东西给大家。&lt;/p&gt;

&lt;p&gt;其次是提高英语的口语能力，多说，多听。&lt;/p&gt;

&lt;h2&gt;规划&lt;/h2&gt;

&lt;p&gt;在研究生的三年中，我需要达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行力：下定决心去做好每一件事&lt;/li&gt;
&lt;li&gt;了解自己研究方向：数据挖掘的方方面面，达到一个比较高的级别&lt;/li&gt;
&lt;li&gt;算法能力再提升一个档次，把算法从劣势转为优势&lt;/li&gt;
&lt;li&gt;对于大数据，云计算，虚拟化有比较深入的了解&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;目标并不多，也不是很远大，但仍然需要认真地去执行。&lt;/p&gt;

&lt;p&gt;另外，希望在这将近一年的实习生涯中达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;精通php,python&lt;/li&gt;
&lt;li&gt;对mysql性能优化有完整的理解和解决方案&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;前方路已经越发明朗了，接下来就是坚定地走下去。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ArchLinux 安装经过</title>
   <link href="http://username.github.com/linux/2012/09/14/archlinux-installation"/>
   <updated>2012-09-14T00:00:00+08:00</updated>
   <id>http://username.github.com/linux/2012/09/14/archlinux-installation</id>
   <content type="html">&lt;p&gt;因为实在受不了Ubuntu的更新繁琐，终于还是下定决心安装ArchLinux了。虽说安装起来要比Ubuntu的无脑安装要艰辛许多，
可是成功之后的除了用起来爽很多之外，这其中的过程也是很有意义的。Arch的好处嘛，除了更新方便之外，源也比Ubuntu的
要快很多，社区服务用起来也比Ubuntu更加方便。废话不多说，直接说安装过程。&lt;/p&gt;

&lt;h2&gt;准备工作&lt;/h2&gt;

&lt;p&gt;当然首先是从arch的Download上下载iso文件，然后把它写到U盘中用于U盘引导安装，关于U盘引导，请参照&lt;a href=&quot;https://wiki.archlinux.org/index.php/USB_Installation_Media&quot;&gt;USB Installation Media&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我下的是2012.08.04的iso，刻录U盘的软件使用的是Linux Live USB Creator，上述页面中的其他的好像都不能正确引导，所以我还是推荐这个。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h2&gt;基本安装&lt;/h2&gt;

&lt;p&gt;能够正确引导的话就可以进行安装了，安装的时候我完全是照着Wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/Beginners'_Guide&quot;&gt;Beginner's Guide&lt;/a&gt;一步步过来的。
只是有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为在开始安装基础包的时候需要网络链接，在网络连接的时候我采用的是static IP的有线连接，在设置网络的时候只需要正确设置有线连接即可。&lt;/li&gt;
&lt;li&gt;在设置硬盘的时候一定要小心，一般情况下用于安装arch的硬盘已经排到了sda4以后，不要照着Beginner's Guide上面敲sda1等，稍不注意就会把windows给格掉。&lt;/li&gt;
&lt;li&gt;在设置mirrorlist时，建议把China的几个server单独选出作为新的mirrorlist文件,这样比较稳定。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Configure BootLoader时，我用的是GRUB，同时要安装os-prober,这样能够自动检测其他系统然后会为这些系统建立引导项。命令也就几行:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  # pacman -S grub-bios
  # grub-install --target=i386-pc --recheck /dev/sda
  # cp /usr/share/locale/en\@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo
  # pacman -S os-prober
  # grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在注意以下几点之后，就能完成基本的安装了。能够有一个命令行下的基本archlinux系统了。&lt;/p&gt;

&lt;h2&gt;扩展安装&lt;/h2&gt;

&lt;p&gt;在完成基本安装之后，我安装了以下扩展。&lt;/p&gt;

&lt;h3&gt;增加用户&lt;/h3&gt;

&lt;p&gt;这个只需要用&lt;code&gt;useradd&lt;/code&gt;命令即可。&lt;/p&gt;

&lt;h3&gt;安装sudo&lt;/h3&gt;

&lt;p&gt;通过pacman进行简单安装，然后通过visudo将需要的用户添加到sudolist中。&lt;/p&gt;

&lt;h3&gt;安装Gnome3&lt;/h3&gt;

&lt;p&gt;首先是安装必备的几个包:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xorg-server xorg-xinit xorg-server-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装显卡驱动，我的显卡是nvida的，选用的驱动是nouveau：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xf86-video-nouveau
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装gnome,dbus,gdm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome, dbus, gdm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时将dbus，gdm添加到/etc/rc.conf的daemons数组中。&lt;/p&gt;

&lt;p&gt;然后安装gnome-tweak-tool用来调节gnome的主题和字体等:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome-tweak-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;设置中文和字体&lt;/h3&gt;

&lt;p&gt;这个部分用来设置archlinux的中文支持和中文字体。&lt;/p&gt;

&lt;h4&gt;设置locale&lt;/h4&gt;

&lt;p&gt;修改/etc/locale.gen文件，将以下行的注释去掉:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;en_US.UTF8 UTF-8
zh_CN.UTF8 UTF-8
zh_CN.GBK GBK
zh_CN.GB2312 GB2312
zh_CN.GB18030 GB18030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在/etc/rc.conf中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCALE=en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在~/.xprofile中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LANG=zh_CN.UTF-8
export LC_ALL=&quot;zh_CN.UTF-8&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;设置中文字体：&lt;/h4&gt;

&lt;p&gt;安装以下字体包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming ttf-fireflysung
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在gnome的高级设置中设置字体:我把所有的字体都设为文泉驿等宽正黑，这种字体中文和英文都比较圆滑。&lt;/p&gt;

&lt;h3&gt;设置无线网络：&lt;/h3&gt;

&lt;p&gt;首先安装networkmanager，然后按照wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/NetworkManager&quot;&gt;NetWorkManager&lt;/a&gt;进行设置/etc/rc.conf。&lt;/p&gt;

&lt;p&gt;添加networkmanager到daemons数组，同时删除network。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DAEMONS=(syslog-ng crond dbus networkmanager sshd gdm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释interface那一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#interface=eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装network-manager-applet，这样就能在gnome启动的时候打开NetWorkManager，可以通过NetWorkManager管理无线网络和有线网络了，
就跟在Ubuntu中一样。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;至此，我安装了我现在archlinux的主要部分，过程虽然比较复杂，但是只要照着wiki来，就能正确完成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://username.github.com/2012/09/13/hello-world"/>
   <updated>2012-09-13T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/09/13/hello-world</id>
   <content type="html">&lt;p&gt;Github 真是个好东西，除了给你提供很好的代码托管服务，还提供了建立个人博客站点的功能。&lt;/p&gt;

&lt;p&gt;我这个博客就是通过Github Pages加上Jekyll创建的。&lt;/p&gt;

&lt;p&gt;想知道怎么回事？请看&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;Jekyll Quick Start&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有时间的话我就会来上面写写，感兴趣的话可以多来看看。我希望能够多谈谈自己所碰到的问题，以及是如何解决的，
借此来启发大家不要跟我犯同样的错误，也可以少走很多弯路。在这个博客中，只谈技术，不聊国事。&lt;/p&gt;

&lt;p&gt;好东西在天朝是不能存活下去的，github也不能幸免。我只希望我亲爱的祖国，能让我多用它一段时间，这样我也就满意了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://username.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://username.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we'll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2&gt;Overview&lt;/h2&gt;

&lt;h3&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &quot;a simple, blog aware, static site generator&quot;.&lt;/p&gt;

&lt;h3&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;


&lt;h3&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files,
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
&lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
&lt;li&gt;No internet connection required.&lt;/li&gt;
&lt;li&gt;Ability to publish via git.&lt;/li&gt;
&lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
&lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
&lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;


&lt;h1&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you'll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br/&gt;
  Stores configuration data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br/&gt;
  This folder is for partial views.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br/&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br/&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br/&gt;
  This is where the generated site will be placed once Jekyll is done transforming it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br/&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &quot;objects&quot; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br/&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br/&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory.
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br/&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br/&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post's YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br/&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &quot;set&quot;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &quot;lessons/beginner&quot;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won't find &quot;lessons&quot; and &quot;beginner&quot; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br/&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br/&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br/&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br/&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br/&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br/&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br/&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br/&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page's or post's content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br/&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br/&gt;
Templates should be coded in HTML and contain YAML Front Matter.
All templates can contain Liquid code to work with your site's data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br/&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;p&gt;  &lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;#123;{content}&amp;amp;#125;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they
define another &quot;root&quot; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3&gt;Includes&lt;/h3&gt;

&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data.&lt;/p&gt;

&lt;h3&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;.
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can't do jackshit in liquid that hasn't been allowed explicitly by the implementation.
What's more you can only access data-structures that have been explicitly passed to the template.&lt;/p&gt;

&lt;p&gt;In Jekyll's case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins.
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br/&gt;
My personal stance is to not invest time trying to hack liquid. It's really unnecessary
&lt;em&gt;from a programmer's&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I've built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files.&lt;/p&gt;

&lt;h2&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br/&gt;
  This is done with textile or markdown.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br/&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br/&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;  &lt;br/&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br/&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We've outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you'd expect; as a nested sub-template.&lt;/p&gt;

&lt;h2&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll's job is to generate a static representation of your website.
The following is an outline of how that's done:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br/&gt;
Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br/&gt;
Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one
big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
At this stage your site is one big computed ruby object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br/&gt;
Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &quot;liquified&quot;. &lt;br/&gt;
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br/&gt;
 Finally the liquid templates are &quot;rendered&quot;, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br/&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you'll iterate through and format
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
&lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at &lt;a href=&quot;&quot;&gt;&lt;/a&gt;
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you'd like.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
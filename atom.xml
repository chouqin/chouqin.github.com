<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Chouqin & Laoqi</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2012-12-22T21:45:48+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Qiping Li</name>
   <email>liqiping1991@gmail.com</email>
 </author>

 
 <entry>
   <title>贪心算法和B树</title>
   <link href="http://username.github.com/clrs/2012/12/18/clrs-1618"/>
   <updated>2012-12-18T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/12/18/clrs-1618</id>
   <content type="html">&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;--&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/custom/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;section&quot;&gt;贪心算法&lt;/h2&gt;
&lt;p&gt;动态规划是一种解决问题的通用方法，
在求解最优化问题的时候，
动态规划能够综合考虑到各种情况然后做出最优的选择。
可是，对于一些特殊的问题，
在从子问题中做出选择时，可以不用考虑所有的子问题，
而只需要考虑一个子问题，
因为选择这个子问题一定可以达到一个最优解，
在这种情况下，就可以采用贪心算法来解决。
贪心算法的好处在于，不需要考虑所有的子问题，
只需要考虑一种情况，这时求解的子问题的数目就减少了，
同时，可以采用一种自顶向下的方法解决问题，
逐步地把问题转化为更小的子问题，直到可以轻易解决。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;从动态规划到贪心&lt;/h3&gt;
&lt;p&gt;书上给出了一个这样的例子来说明从动态规划算法转化到贪心算法。&lt;/p&gt;

&lt;p&gt;有n个活动组成集合&lt;script type=&quot;math/tex&quot;&gt; S = \{a_1, a_2, ..., a_n\} &lt;/script&gt;，它们需要占用同一个资源，
这个资源在同一个时间只能被一个活动占用，每一个活动&lt;script type=&quot;math/tex&quot;&gt; a_i &lt;/script&gt;使用资源的起始时间和结束时间分别为
&lt;script type=&quot;math/tex&quot;&gt; s_n, f_n &lt;/script&gt;，如果区间&lt;script type=&quot;math/tex&quot;&gt; [s_i, f_i) &lt;/script&gt;与区间&lt;script type=&quot;math/tex&quot;&gt; [s_j, f_j) &lt;/script&gt;不重叠，
就称活动&lt;script type=&quot;math/tex&quot;&gt; a_i &lt;/script&gt;与活动&lt;script type=&quot;math/tex&quot;&gt; a_j &lt;/script&gt;是兼容的，求S的一个由互相兼容的活动组成的最大子集，
假设活动已经按结束时间排好序。&lt;/p&gt;

&lt;p&gt;对于这个问题，可以定义如下子问题&lt;script type=&quot;math/tex&quot;&gt; S_{ij} &lt;/script&gt;，
表示从S的子集&lt;script type=&quot;math/tex&quot;&gt; S_{ij} &lt;/script&gt;中得到的最大兼容子集，
其中&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 S_{ij} = \{ a_k \in S: s_k \geq f_i and f_k &lt; s_j \} %]]&gt;&lt;/script&gt;，
也就是说，&lt;script type=&quot;math/tex&quot;&gt; S_{ij} &lt;/script&gt;是由所有在&lt;script type=&quot;math/tex&quot;&gt; a_i &lt;/script&gt;结束之后开始，
在&lt;script type=&quot;math/tex&quot;&gt; a_j &lt;/script&gt;开始之前结束的活动组成的集合。
通过定义这样一个子问题，
就可以很容易地得出如下递推公式，&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
A_{ij} = A_{ik} \bigcup \{a_k\} \bigcup A_{kj}, 其中A_{ij}表示子问题S_{ij}的解
&lt;/script&gt;

&lt;p&gt;从而利用动态规划解决这个问题。&lt;/p&gt;

&lt;p&gt;然而，动态规划并不是一个最优的解法，
因为要求解的子问题的个数为&lt;script type=&quot;math/tex&quot;&gt; O(n^2) &lt;/script&gt;个，
而且求解每个子问题时选择的个数也有&lt;script type=&quot;math/tex&quot;&gt; O(n) &lt;/script&gt;个，
这就导致了通过动态规划求解问题所需的复杂度为&lt;script type=&quot;math/tex&quot;&gt; O(n^3) &lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;如果采用贪心的算法，每次通过选取&lt;script type=&quot;math/tex&quot;&gt; S_{ij} &lt;/script&gt;中具有最早结束时间的活动&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;作为划分元素的话，
那么就可以通过&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
A_{ij} = A_{im} \bigcup \{a_m\} \bigcup A_{mj}
&lt;/script&gt;

&lt;p&gt;得到一个最优的解，而不用考虑其它元素作为划分元素时的子问题。&lt;/p&gt;

&lt;p&gt;定义函数递归函数RECURSIVE-ACTIVITY-SELECTOR(S, f, i, n)求取子问题&lt;script type=&quot;math/tex&quot;&gt; S_{i(n+1)} &lt;/script&gt;的解，
伪代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def RECURSIVE-ACTIVITY-SELECTOR(s, f, i, n)
    m := i + 1
    while m &amp;lt;= n and s[m] &amp;lt; f[i]
        do m := m + 1
    if m &amp;lt;= n
        then return {a[m]} union RECURSIVE-ACTIVITY-SELECTOR(s, f, m, n)
        else return EMPTY_SET
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;求解原问题就可以通过调用RECURSIVE-ACTIVITY-SELECTOR(s, f, 0, n)来完成。
从代码中可以看出，每个活动都只被检查过一次，如果函数调用的时间可以忽略不计的话(
这个递归地算法可以通过迭代来实现，所以算法本身可以不用考虑这个问题)，
那么整个算法的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt; \Theta(n) &lt;/script&gt;。相比于动态规划，效率要提高很多。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;关于这个问题的几点解释&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;关于为什么可以将&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;选作分界元素需要说明两点：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;一定有某一个最大兼容子集包含元素&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;，也就是说，
 如果要挑选出一些元素组成最大兼容子集，
 那么先把&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;选中放入这个集合中肯定能导致一个最优解。
 关于这种命题的证明，普遍的方式是假设有一个最优解没有包含这个元素，
 那么把这个元素和某个元素替换后会导致一个不会比原来差的解。
 书上也是采取这样的证明方式。以后在证明最小生成树的贪心算法时也是采取这样的方式。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;把&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;放入最大兼容子集后，这个最大兼容子集的其余元素一定是子问题&lt;script type=&quot;math/tex&quot;&gt; S_{mj} &lt;/script&gt;的一个解。
 这个比较好证明，只需要证明对于任意和&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;兼容的元素&lt;script type=&quot;math/tex&quot;&gt; a_k &lt;/script&gt;, 一定有
 &lt;script type=&quot;math/tex&quot;&gt; s_k \geq f_m &lt;/script&gt;即可。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;有了这两点，就能得出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
 A_{ij} = \{a_m\} \bigcup A_{mj} = A_{im} \bigcup \{a_m\} \bigcup A_{mj}, 第二个等式成立是因为A_{im} = \emptyset
 &lt;/script&gt;

    &lt;p&gt;也就是将&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;选作分界元素, 同时可以不需要求解&lt;script type=&quot;math/tex&quot;&gt; S_{im} &lt;/script&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的是&lt;script type=&quot;math/tex&quot;&gt; S_{ij} \neq \{a_{i+1}, a_{i+2}, ..., a_{j-1} \}&lt;/script&gt;，
这个等式只有在&lt;script type=&quot;math/tex&quot;&gt; i=0, j=n+1 &lt;/script&gt;时成立，
但是从代码中我们可以看到，
在调用RECURSIVE-ACTIVITY-SELECTOR(S, f, i, n)时，
此时可能被添加进最大兼容子集的元素集合是&lt;script type=&quot;math/tex&quot;&gt; \{a_{i+1}, a_{i+2}, ..., a_{n} \} &lt;/script&gt;,
而不是&lt;script type=&quot;math/tex&quot;&gt; S_{i(n+1)} &lt;/script&gt;，然而这并不会导致什么问题，因为在选取&lt;script type=&quot;math/tex&quot;&gt; a_m &lt;/script&gt;时，已经过滤掉了开始时间小于&lt;script type=&quot;math/tex&quot;&gt; f_i &lt;/script&gt;的元素，
随着迭代次数的加深，那些开始时间小于&lt;script type=&quot;math/tex&quot;&gt; f_i &lt;/script&gt;的元素也会被过滤掉，因为开始时间小于&lt;script type=&quot;math/tex&quot;&gt; f_i &lt;/script&gt;也一定会小于&lt;script type=&quot;math/tex&quot;&gt; f_m &lt;/script&gt;，
在更深的迭代时同样会被过滤。&lt;/p&gt;

    &lt;p&gt;采取这样的方式实现代码能够降低时间和空间的复杂度，因为如果每次求解子问题时都需要求出&lt;script type=&quot;math/tex&quot;&gt; S_{ij} &lt;/script&gt;这个集合的话，
 需要&lt;script type=&quot;math/tex&quot;&gt; O(n) &lt;/script&gt;的时间来求出，同时也需要一个数组来保存这个子集，显然不如书上的这个实现简单。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这个问题如果用动态规划的话可以采用另外一种思路，
令c[i]表示集合&lt;script type=&quot;math/tex&quot;&gt; \{a_1, ..., a_i \} &lt;/script&gt;中，包含元素&lt;script type=&quot;math/tex&quot;&gt; a[i] &lt;/script&gt;的最大兼容子集的元素个数，
那么有如下递归公式成立&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

 c[i] = \max \{\max_{j &lt; i}_{s_i &gt; f_j } \{c[j] + 1\}, 1 \}
  %]]&gt;&lt;/script&gt;

    &lt;p&gt;利用这个递归公式求解的话，时间复杂度可以降到&lt;script type=&quot;math/tex&quot;&gt; O(n^2) &lt;/script&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-3&quot;&gt;贪心算法的基本条件&lt;/h3&gt;
&lt;p&gt;总的来说，贪心算法比动态规划效率要高，实现起来也相对简单一些，
同时也是一般人比较容易想到的算法。但是这并不意味着它比较简单，
因为并不是所有的问题都能够使用贪心法得到解决，
它比动态规划有更多的限制条件，
它必须满足两个基本条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;贪心选择性质：一个全局最优解可以通过局部最有解得到。
这是贪心算法与动态规划的不同之处。
证明贪心选择性质一般用上面提到的修改最优解，
使其包含局部最优解，
然后得到一个不差于最优解的解，就能证明。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最优子结构，这和动态规划一样，可以通过&amp;#8221;剪切，粘贴&amp;#8221;的方法证明。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-4&quot;&gt;哈夫曼编码&lt;/h3&gt;

&lt;p&gt;贪心算法可以用于求解很多问题，
在图算法中的最小生成树算法，
单源最短路径算法等都是利用贪心法解决，
关于这些算法，我在图算法时再详细阐述，
现在说另外一个比较典型的贪心算法的例子。&lt;/p&gt;

&lt;p&gt;哈夫曼编码，这个基本是任何算法书都需要提及的使用贪心算法的例子。
有n个不同字符，知道它们的出现的出现次数，
如何设计一个前缀编码使得整个文件的编码最短。利用一个优先级队列，
每次把队列的频率最小的两个元素出队，组成一个新的元素然后入队，直到队列只剩一个元素为止。
这个算法贪心选择性质的证明也比较简单。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;另一种贪心算法&lt;/h3&gt;

&lt;p&gt;前面说到的贪心算法都是用于求解最优化问题，
在应用贪心算法的时候，看问题是否具备贪心选择的性质，
如果具备，就通过贪心法求解。
有另外一种问题也可以归入贪心算法的范畴，这样的问题不是求最优解，
而只是需要正确地的解决某一个问题，在这种问题中，没有最优解可言，
只是求出问题的正确的解就可以。在解决问题的过程中，可能会有很多选择，
类似于要不要选择某个元素，要不要把某个变量设成True，
这许多的选择组合起来就会导致解有很多种可能性，
目的就在于从这许多的解中找出满足指定条件的一个解，如果存在的话。
这就类似于走迷宫，有许多的分叉路口，就很多种走法，
从这些走法中找出一个能走到出口的就可以。&lt;/p&gt;

&lt;p&gt;对于这些问题，暴力搜索每一种可能性显然不是一种好方法，
动态规划也可以用于解决这样的问题，
在解决一个问题时利用一个子问题是否满足条件来决定当前的问题是否满足条件。
而贪心算法在解决这种问题时采取了一种更加直观的想法: 必须要做某一个选择，
否则就是不满足条件的解。如果问题具有这样的性质，就可以很容易地选出一个解，
因此每次的选择都是唯一的，然后再看这个选择是否满足条件即可。如果满足条件，
那么就找到了一个解，如果不满足，那么就没有解，因为其他的解肯定不满足条件。
下面通过Horn公式来更详细的说明。&lt;/p&gt;

&lt;p&gt;在Horn公式中，我们指定了一些布尔变量(比如x，y, z)必须满足的性质，通过两种公式给出:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;蕴含式：在这种公式中，左边为合取范式，右边为单一变量, 所有变量必须不含否定，比如&lt;script type=&quot;math/tex&quot;&gt; (z \bigwedge w)  \Longrightarrow u &lt;/script&gt;
或者&lt;script type=&quot;math/tex&quot;&gt; \Longrightarrow x &lt;/script&gt;,
而&lt;script type=&quot;math/tex&quot;&gt; (z \bigwedge \bar w)  \Longrightarrow u &lt;/script&gt;就不是这种蕴含式&lt;/li&gt;
  &lt;li&gt;完全由变量的否定组成的析取范式, 比如 &lt;script type=&quot;math/tex&quot;&gt; (\bar u \bigvee \bar v \bigvee \bar y )&lt;/script&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;问题是给定一个Horn公式，确定是否可以给公式中出现的变量赋予合适的布尔值，使所有的这些公式都能得到满足。
很显然，要满足蕴含式，需要要把一些变量设为True, 而要满足析取范式，需要把一些变量设为False。
对于每一个变量，赋值的方式都有两种，遍历所有的可能性显然是效率不高的。&lt;/p&gt;

&lt;p&gt;贪心算法通过这样的思路来解决：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先把变量都设为False，&lt;/li&gt;
  &lt;li&gt;如果有蕴含式不满足，就把蕴含式右边的变量设成True，然后继续这个步骤直到所有的蕴含式都满足为止, 否则到步骤3。&lt;/li&gt;
  &lt;li&gt;查看是否有析取范式不满足，如果全满足，那么就找到了一个解，否则，无解。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;说明两点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为什么这个算法是正确的。如果找到了一个解，显然是正确的。
如果没找到解，为什么就无解呢？因为前面的把变量设为True是“必须”的，
也就是说，一个变量被设为True，那么在任何正确的解中，它必须被设为True，
所有在这些必须的步骤都完成之后，如果不满足条件，也就没有解可以满足条件了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重复检查所有蕴含式是否满足的次数的不超过n+1次，其中n为变量的个数。
因为除了第一次检查，其余每一次检查都是因为前一次有变量被设为True，
(否则如果没有变量被设为True, 那么所有的蕴含式都满足，就不会再去检查了),
而变量被设为True的次数不超过n次，所以检查次数不超过n+1次，
这就保证了检查所有蕴含式是否满足并不是一个复杂度非常高的过程。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这种贪心算法中，解决思路是找出那些必须要执行的步骤，一步一步，将问题简化，
最终解决。&lt;/p&gt;

&lt;h2 id=&quot;b&quot;&gt;B树&lt;/h2&gt;

&lt;p&gt;B树也是一种平衡地二叉查找树，类似于红黑树，
它也能够支持动态地插入，删除和查找数据。
B树主要用于保存数据到磁盘中，
比如很多数据库的索引就是通过B树进行保存。
由于磁盘的读取速度相对于内存要慢得多，
所以尽量地减少IO的次数显得非常重要，
B树也正是实现了这样的思想，B树的深度不会太深，
这样查找数据所需要遍历的节点数就会很少，
相应的IO次数也会减少。&lt;/p&gt;

&lt;p&gt;在B树中，一个非根的节点至少包含t-1个关键字，
这样每一个非根的节点就至少有t个子女，这样一棵包含n个关键字的B树的高度h至多为
&lt;script type=&quot;math/tex&quot;&gt; \log t \frac{n+1}{2} &lt;/script&gt;。但是一个节点包含的关键字又不能太多，
一方面是因为一次IO只能读取指定数量的字节，
另一方面太多的关键字会导致定位一个关键字比较耗时，所以B树的每个节点包含至多2t-1个关键字。&lt;/p&gt;

&lt;p&gt;这些性质能够保证B树查找的性能，但是在插入和删除的时候就需要维护这些性质。
具体表现在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当插入一个关键字到一个已经满了节点（包含2t-1个关键字），就需要把这个节点分裂成两个，
同时把这个节点中间关键字插入到它的父节点，这样可能会导致父节点的关键字超过2t-1，
所以需要一直向上到根来进行维护。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当删除一个关键字时，会导致只有t-1个关键字的节点不满足性质，这时可以通过向它的兄弟“借”一个关键字，
如果兄弟包含至少t个关键字的话，否则，就和兄弟合并，然后从父节点删除一个关键字，
同样的，此时需要一直向上到根来进行维护。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;书上在插入和删除节点的时候为了避免向上过滤来进行维护，
在遍历到某一个节点的时候，就把性质维护好，这样当一个节点遍历到的时候，
就能保证它的父节点不需要再去维护了。这样的方法，对于插入还好，
对于删除操作就显得有点复杂，考虑了好多种情况，
我觉得还是向上过滤进行维护比较好，并没有增加复杂度。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>红黑树扩充与动态规划</title>
   <link href="http://username.github.com/clrs/2012/12/12/clrs-14-15"/>
   <updated>2012-12-12T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/12/12/clrs-14-15</id>
   <content type="html">&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/custom/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;--&gt;

&lt;h2 id=&quot;section&quot;&gt;红黑树的扩充&lt;/h2&gt;

&lt;p&gt;由于红黑树这种结构很好的平衡性（树的高度不会很高），
对于动态变化的集合插入，查找，删除等操作的复杂度都比较低，
通过给它的节点增加一些其他的属性，
能够得到一些在特定情况下很有用的数据结构。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;扩充数据结构的四个步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;选择基础的数据结构&lt;/li&gt;
  &lt;li&gt;确定需要给数据结构添加哪些信息，
这些信息可能被添加到每个节点中，也可能被添加作为整体数据结构的性质&lt;/li&gt;
  &lt;li&gt;验证在数据结构的基本操作的过程中，这些信息可以被有效的维护，
这里的有效是指不会因为维护这些信息增加基础操作的复杂度&lt;/li&gt;
  &lt;li&gt;利用这些信息提供一些有用的操作&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-2&quot;&gt;通过扩充红黑树得到顺序统计&lt;/h3&gt;

&lt;p&gt;通过给红黑树的每一个节点x附加属性size[x]，
表示以x为根的子树的节点个数，
可以通过递归确定一棵红黑树的第i小关键字的元素。
由于包含n个元素的红黑树的高度为&lt;script type=&quot;math/tex&quot;&gt; O(\lg n) &lt;/script&gt;，每次递归高度都会下降一层，
所以查找第i小关键字的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt; O(\lg n) &lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;在第9章中，给出了获取n个元素的数组中第i个元素的&lt;script type=&quot;math/tex&quot;&gt; \Theta(n) &lt;/script&gt;的算法，
而一个包含n个元素的数组如果是有序的话，那么获取第i个元素的复杂度是&lt;script type=&quot;math/tex&quot;&gt; O(1) &lt;/script&gt;。
但是这种扩充的数据结构的好处在于它的动态性，它的插入和删除的时间复杂度也是&lt;script type=&quot;math/tex&quot;&gt; O(\lg n) &lt;/script&gt;，
而一个有序数组的插入和删除的复杂度是&lt;script type=&quot;math/tex&quot;&gt; O(n) &lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;通过扩充红黑树得到区间树&lt;/h3&gt;

&lt;p&gt;在区间树中，每一个节点x包含了一段区间int[x]，同时包含了一个max[x]，
表示以x为根的子树中所有区间的右端点的最大值，同时每一个节点的key[x] = low[int[x]]，
也就是说是把每一个节点所包含区间的左端点作为key。&lt;/p&gt;

&lt;p&gt;区间树使得查找整个红黑树中与某一个区间i重合的区间变得十分容易，
可以如下递归实现：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果当前节点为空，返回空节点&lt;/li&gt;
  &lt;li&gt;如果区间i与当前节点的区间重合，返回当前节点&lt;/li&gt;
  &lt;li&gt;如果区间i的左端点小于当前节点左儿子的max，递归查找左子树&lt;/li&gt;
  &lt;li&gt;否则递归查找右子树&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;情况1，2很自然，情况4也比较好理解，
因为如果i的左端点大于左儿子的max，它就大于那么对于左子树中所有节点的右端点，
左子树中一定不存在和区间i重合区间。情况3需要一定的思考，
因为如果i的左端点小于当前节点左儿子的max，并不能保证它一定不会与右子树中的区间重合，
所以如果只是递归查找左子树，如果左子树中有区间和i重合，那么能够返回正确结果
（因为只需要找到一个和i重合的区间就可以），如果左子树中没有区间与i重合，
那右子树中可能会有区间与i重合，导致没有返回正确的结果。情况是这样的吗？&lt;/p&gt;

&lt;p&gt;不是这样的，下面可以证明在情况3时如果左子树中没有找到与i重合的区间，
那么在右子树中也一定不存在和i重合的区间。&lt;/p&gt;

&lt;p&gt;假设左儿子的max来自于high[j]（也就是说，是左子树中区间j的右端点)，
那么一定有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
 
high[i] &lt; low[j]
 %]]&gt;&lt;/script&gt;

&lt;p&gt;否则区间i和j重合，对于右子树中的任意区间k，一定有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; 
low[k] \geq low[j] &gt; high[i] \text{第一个不等式成立是根据红黑树关键字的性质}
&lt;/script&gt;

&lt;p&gt;所以k与i不重合。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;动态规划&lt;/h2&gt;

&lt;!--more--&gt;

&lt;p&gt;动态规划主要用于求解最优化问题，
它的基本思想是通过把子问题的结果保存起来，
这样当遇到一个更大的问题时，如果它需要解决子问题，
那么可以直接使用保存好的子问题的结果，而不用再去重复解决子问题。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;动态规划适用的基本条件&lt;/h3&gt;

&lt;p&gt;使用动态规划必须要满足两个基本的条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最优子结构。一个问题的最优解包含子问题的最优解。
通常可以通过&amp;#8221;剪切-粘贴&amp;#8221;的方法证明最优子结构，也就是说，
假设一个问题的最优解没有包含子问题的最优解，
那么把相应的子问题的解替换成最优解将得到一个更好的解，
从而得出矛盾。&lt;/li&gt;
  &lt;li&gt;重叠子问题。如果没有大量的重叠子问题，
那么直接通过递归求解子问题就可以，
动态规划相对于递归的好处也就在于不用重复去计算重叠的子问题，
从而节省了时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-6&quot;&gt;动态规划解题的基本思路&lt;/h3&gt;

&lt;p&gt;在确定了一个问题适合采用动态规划进行解决之后，
仍然需要考虑几个问题。最主要的问题就是如何将问题利用更小的子问题来进行解决，
此时的思路是通过把原来的问题通过转化变成更小的子问题，
利用合适的转化可以把一个问题缩小成一个更小的子问题，比如最长递增子序列问题，
求以元素n结尾的最长递增子序列的长度，
可以转化为求以比n小的排在n前面的某个元素结尾的最长递增子序列的长度。
通过转化之后问题就缩小了。&lt;/p&gt;

&lt;p&gt;将问题转换成子问题之后，必须要知道如何通过子问题的解得到原问题的解，
也就是所谓的递推公式，
比如上述问题，知道n之前的某个小于n元素的最长子序列的长度之后，
n的最长子序列的长度就是这个长度加1。&lt;/p&gt;

&lt;p&gt;一个问题可能转化成多个子问题，比如说上面的问题，
比n小的排在n之前的元素可能有多个，这时，就需要从多个子问题之间做出选择。
这个选择通常是比较容易的，直接从所有根据子问题递推得到的解中选出一个最优解即可。
一般情况下，还需要记录此时的选择，用于构造出一个最优解。&lt;/p&gt;

&lt;p&gt;把上述的问题都考虑好之后，就可以按照问题的大小，
从小到大依次将各个问题解决，直到达到所需要的问题的大小，
就得到了所需问题的解。&lt;/p&gt;

&lt;h3 id=&quot;section-7&quot;&gt;动态规划的经典问题&lt;/h3&gt;

&lt;h4 id=&quot;lcs&quot;&gt;最长公共子序列（LCS）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;问题描述：
定义序列&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 X = &lt;x_1, x_2, ..., x_m&gt;  %]]&gt;&lt;/script&gt;的一个子序列为
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 Z = &lt;x_{i_1}, x_{i_2}, ..., x_{i_k}&gt;  %]]&gt;&lt;/script&gt;，其中
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 i_1 &lt; i_2 &lt; ... &lt; i_k, k \geq 1  %]]&gt;&lt;/script&gt;。求两个序列
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 X = &lt;x_1, x_2, ..., x_m&gt;  %]]&gt;&lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 Y = &lt;y_1, y_2, ..., y_n&gt;  %]]&gt;&lt;/script&gt;的最长公共子序列的长度c[m, n]。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;求解方法：
定义c[i, j]为序列&lt;script type=&quot;math/tex&quot;&gt; X_i &lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt; Y_j &lt;/script&gt;的LCS的长度，
有如下递推公式成立&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
 
      c[i, j] = 
          \begin{cases}
              0 &amp; \text{i=0 或j=0} \\
              c[i-1, j-1] + 1 &amp; i,j &gt; 0, x_i = y_j \\
              max\{c[i, j-1], c[i-1, j]\} &amp; i,j &gt; 0, x_i \neq y_j
          \end{cases}
   %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;说明:
其实c[i, j]有三个子问题， c[i-1, j-1], c[i-1, j], c[i, j-1],
为什么当&lt;script type=&quot;math/tex&quot;&gt; x_i = y_j &lt;/script&gt;时只需要考虑第一个子问题，因为有如下不等式成立:&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
c[i-1, j-1] + 1 \geq c[i, j-1] \\
c[i-1, j-1] + 1 \geq c[i-1, j]
&lt;/script&gt;

&lt;p&gt;因为c[i, j-1]相对于c[i-1, j-1]就多了一个元素c[i]，
最多能够为最长公共子序列多增加长度1，同理对于c[i-1, j]也是如此。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;背包问题&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;问题描述：
给定一个重量为w的背包，有n件商品重量分别为&lt;script type=&quot;math/tex&quot;&gt; w_1, w_2, ..., w_n &lt;/script&gt;,
价值分别为&lt;script type=&quot;math/tex&quot;&gt; v_1, v_2, ..., v_n &lt;/script&gt;，求这个背包能容纳的最大的商品价值&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;问题求解：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果对于每一件商品，可以拿取任意多次，则定义K(w)表示重量为w的背包最大的价值，
  有如下递推关系成立：&lt;/li&gt;
    &lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

  K(w) = max\{K(w-w_i) + v_i\}, i=1..n, w_i &lt; w
   %]]&gt;&lt;/script&gt;

    &lt;ul&gt;
      &lt;li&gt;如果没一件商品只能拿一次，就不能采取上面的方法了，因为如果在K(w)转换至&lt;script type=&quot;math/tex&quot;&gt; K(w-w_i) &lt;/script&gt;时使用了
  商品i, 在求解&lt;script type=&quot;math/tex&quot;&gt; K(w-w_i) &lt;/script&gt;就不能再使用商品i,上述的递推公式不成立。必须采用另外一种方法。
  定义K(w, i)为重量为w的背包在装载商品1..i时的最大价值，有如下递推关系成立：&lt;/li&gt;
    &lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

  K(w, i) = max\{K(w-w_i, i-1) + v_i, K(w, i-1)\}, i=1..n, w_i &lt; w
   %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;floyd&quot;&gt;Floyd算法的正确性&lt;/h3&gt;

&lt;p&gt;Floyd算法用于求解图中所有节点中的最短路径。
基本思想是通过n（n为节点个数）次循环更新所有节点对之间的最短路径，
伪代码如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;pascal&quot;&gt;    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在每次迭代时，对于任意节点对(i, j)，如果(i, k)的路径长度加(k, j)的路径长度小于
原来的(i, j)的路径长度，
那么就将(i, j)的路径长度更新为(i, k)的路径长度加(k, j)的路径长度（也就是说，
让(i, j)的最短路径经过k）。
算法的时间复杂度为&lt;script type=&quot;math/tex&quot;&gt; O(n^3) &lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;动态规划对于这个算法的理解是，在迭代k结束之后，
此时(i, j)的最短路径为仅使用{1, 2, &amp;#8230;, k}作为中间节点的最短路径，
当循环结束时，k=n, 此时(i, j)的最短路径为使用任意节点作为中间节点的最短路径，
也就是(i, j)之间的最短路径。&lt;/p&gt;

&lt;p&gt;凭直接感觉，比如说(i, j)之间的最短路径为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
i \rightarrow ... \rightarrow k_1 \rightarrow ... \rightarrow k_2 \rightarrow ... \rightarrow j
&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 k_1 &lt; k_2  %]]&gt;&lt;/script&gt;,
如果最外层的循环遍历到&lt;script type=&quot;math/tex&quot;&gt; k_1 &lt;/script&gt;时，因为此时不能使用&lt;script type=&quot;math/tex&quot;&gt; k_2 &lt;/script&gt;作为中间节点，
所以不会把(i, j)之间的最短路径经过&lt;script type=&quot;math/tex&quot;&gt; k_1 &lt;/script&gt;，
当允许使用&lt;script type=&quot;math/tex&quot;&gt; k_2 &lt;/script&gt;作为中间节点时，
有不会再去遍历&lt;script type=&quot;math/tex&quot;&gt; k_1 &lt;/script&gt;让(i, j)之间的最短路径经过&lt;script type=&quot;math/tex&quot;&gt; k_1 &lt;/script&gt;, 
所以，(i, j)之间的最短路径没有被找到，这个算法好像是错误的。&lt;/p&gt;

&lt;p&gt;我开始老是纠结在这样的感觉中，
认为Floyd算法可能并没有找到一条最短的路径，
可是又总是找不到一个反例，
后面经过仔细地思考，总结出两种方法来说明这个算法的正确性，
解除了我的疑虑。&lt;/p&gt;

&lt;h4 id=&quot;floyd-1&quot;&gt;通过循环不变式来证明Floyd算法的正确性&lt;/h4&gt;

&lt;p&gt;通过证明以下循环不变式证明算法的正确性:&lt;/p&gt;

&lt;p&gt;在第k轮迭代开始前，对于任意节点对(i, j)，
此时的最短路径长度为使用节点{1, 2, .., k-1}作为中间节点的最短路径长度。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化：在开始时，k=1, 此时的最短的路径为不使用任何中间节点的最短路径。&lt;/li&gt;
  &lt;li&gt;保持：在第k轮迭代开始时，
此时(i, j)之间的最短路径为使用{1，2，&amp;#8230;, k-1}作为中间节点的最短路径，
令p为(i, j)之间使用{1, 2, &amp;#8230;, k}的最短路径：
    &lt;ul&gt;
      &lt;li&gt;如果path[i][k] + path[k][j] &amp;lt; path[i][j]，
 那么此时p一定为&lt;script type=&quot;math/tex&quot;&gt; i \xrightarrow{p_1} k \xrightarrow{p_2} j &lt;/script&gt;，
 其中&lt;script type=&quot;math/tex&quot;&gt; p_1 &lt;/script&gt;为(i, k)之间使用{1, 2, &amp;#8230;, k-1}作为中间节点的最短路径，
 &lt;script type=&quot;math/tex&quot;&gt; p_2 &lt;/script&gt;为(k, j)之间使用{1, 2, &amp;#8230;, k-1}作为中间节点的最短路径。
 所以此时p的长度为path[i][k] + path[k][j]，不变式得以保持&lt;/li&gt;
      &lt;li&gt;如果path[i][k] + path[k][j] &amp;gt;= path[i][j]，
 那么此时p一定也是(i, j)仅经过{1, 2, &amp;#8230;, k-1}的最短路径(也就是说，
 此时p一定不经过k)，p的长度就是path[i][j], 不变式同样可以保持&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;终止：循环结束时，k=n+1, 此时(i, j)的最短路径是使用任意节点作为中间节点的最短路径，
也就是(i, j)的最短路径。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于这个循环不变式，定义&lt;script type=&quot;math/tex&quot;&gt; path^{(k)}(i, j) &lt;/script&gt;表示(i, j)之间仅使用节点1,&amp;#8230;,k作为中间节点的最短路径的长度，
利用这个递推公式：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
path^{(k)}(i, j) = min\{ path^{(k-1)}(i, k) + path^{(k-1)}(k, j), path^{(k-1)}(i, j) \}
&lt;/script&gt;

&lt;p&gt;可能要更好理解一些。&lt;/p&gt;

&lt;h4 id=&quot;floyd-2&quot;&gt;通过归纳证明Floyd算法的正确性&lt;/h4&gt;

&lt;p&gt;可以通过这样一种思路来证明：假设k是(i, j)最短路径中最大的中间节点，
也就是说对于(i, j)最短路径中任意的中间节点m, 有&lt;script type=&quot;math/tex&quot;&gt; m \leq k &lt;/script&gt;，这样，
k是(i, j)最短路径中最后被迭代的节点，如果在迭代到k时，
能够将(i, j)之间最短路径长度正确的设置，那么这个算法就是正确的。
在迭代k时，如果(i, k)和(k, j)之间的最短路径已经被正确设置时，
那么(i, j)在迭代k结束之后能够被正确设置。&lt;/p&gt;

&lt;p&gt;下面通过归纳(i, j)路径中中间节点的个数n来证明在迭代k(k是(i, j)最短路径中最后被迭代的节点)时，
(i, k)和(k, j)最短路径已经被正确的设置：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当n=1, 在迭代k时，(i, k)和(k, j)都没有中间节点，
最短路径就是节点i和k以及k和j之间的距离, 已经被正确的设置。&lt;/li&gt;
  &lt;li&gt;如果&lt;script type=&quot;math/tex&quot;&gt; n \leq s &lt;/script&gt;时，命题成立。那么当n=s+1时，在迭代k时，
对于路径(i, k), 它的中间节点的个数&lt;script type=&quot;math/tex&quot;&gt; n_1 \leq s &lt;/script&gt;，
那么当这条路径的最后一个节点&lt;script type=&quot;math/tex&quot;&gt; k_1 &lt;/script&gt;被迭代时，&lt;script type=&quot;math/tex&quot;&gt; (i, k_1) &lt;/script&gt;和&lt;script type=&quot;math/tex&quot;&gt; (k_1, k) &lt;/script&gt;已经被正确设置，
迭代之后，能够将路径(i, k)正确设置，同理可以证明路径(k , j)也能够被正确设置。&lt;/li&gt;
  &lt;li&gt;由上述两步可以得知对于任意个数的中间节点，(i, j)在迭代最后一个节点k时，
(i, k)和(k, j)能够被正确的设置。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-9&quot;&gt;忽略我&lt;/h3&gt;
&lt;p&gt;最后还是吐槽一下动态规划这一章的翻译真的很烂，
感觉和前面的章节不是同一个人翻译的，
很多语句很不通顺，比如说有个反问句就绕了我好久，
试着推测原文才明白什么意思。
人和人之间还是有差距的啊，不管做什么都是，
希望后面的几章能够翻译好一点，bless!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《算法导论》之基本数据结构</title>
   <link href="http://username.github.com/clrs/2012/12/04/clrs-10-13"/>
   <updated>2012-12-04T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/12/04/clrs-10-13</id>
   <content type="html">&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;--&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/custom/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h2 id=&quot;section&quot;&gt;散列表中碰撞的解决&lt;/h2&gt;
&lt;p&gt;由于散列表的元素个数小于关键字的取值集合U,
因此会有两个不同的关键字映射到散列表的同一个槽上，
这时就发生了碰撞。发生了碰撞时，
书上给出了两种方法来解决，
而且保证此时的散列表平均情况下的查找复杂度是O(1)。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;链接法&lt;/h3&gt;
&lt;p&gt;在链接法中，关键字映射到同一个槽上的元素通过一个链表来保存，
此时散列表T[0..m-1]的任意元素T[j]是一个链表，
当插入一个元素时，将元素放在它所对应的槽所指向链表的头部。
下面对链接法的性能进行分析。&lt;/p&gt;

&lt;p&gt;定义散列表T的装载因子&lt;script type=&quot;math/tex&quot;&gt; \alpha = n / m &lt;/script&gt;, 其中n是元素个数，m是散列表槽数,
我们假设元素满足简单一致散列的条件：
任何元素散列到m个槽中的每一个的可能性是相同的。&lt;/p&gt;

&lt;p&gt;用&lt;script type=&quot;math/tex&quot;&gt; n_j &lt;/script&gt;表示链表T[j]的长度，有
$$
E[n_j] = \alpha = n/m
$$&lt;/p&gt;

&lt;p&gt;有如下性质成立：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;链接方式散列表在简单一致假设下，查找一个不存在元素所需时间的期望为&lt;script type=&quot;math/tex&quot;&gt; \Theta (1 + \alpha) &lt;/script&gt;&lt;/p&gt;

    &lt;p&gt;假设查找的元素是k, 它所对应的槽为h(k)，链表T[h(k)]的长度&lt;script type=&quot;math/tex&quot;&gt; E[n_{h(k)}] = \alpha &lt;/script&gt;，
 所以平均情况下需要遍历一个长度为&lt;script type=&quot;math/tex&quot;&gt; \alpha &lt;/script&gt;的链表，外加常数的散列函数时间和寻址T[h(k)]的时间，
 总共为&lt;script type=&quot;math/tex&quot;&gt; \Theta (1 + \alpha) &lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;链接方式散列表在简单一致假设下，平均查找一个已存在的元素所需的时间为&lt;script type=&quot;math/tex&quot;&gt; \Theta (1 + \alpha) &lt;/script&gt;&lt;/p&gt;

    &lt;p&gt;对于任意元素x，检查的元素个数等于x所在链表中，出现在x之前的元素个数加1。
 设&lt;script type=&quot;math/tex&quot;&gt; x_i &lt;/script&gt;是第i个插入的元素，i=1,2,..,n,
 定义：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

     X_{ij} =
      \begin{cases}
          1 &amp; x_i\text{和}x_j\text{在同一槽中} \\
          0 &amp; \text{否则}
      \end{cases}
  %]]&gt;&lt;/script&gt;

    &lt;p&gt;由简单一致性假设，&lt;script type=&quot;math/tex&quot;&gt; E[X_{ij}] = 1/m &lt;/script&gt;，所以检查元素个数的期望为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

 \begin{array} {lcl}
 E[\frac{1}{n} \sum_{i=1}^{n} (1 + \sum_{j=0}^{i-1}X_{ij})]
     &amp;=&amp; 1 + \frac{n-1}{2m} \\
     &amp;=&amp; 1 + \frac{\alpha}{2} - \frac{\alpha}{2n}
 \end{array}
  %]]&gt;&lt;/script&gt;

    &lt;p&gt;所以平均查找时间为: &lt;script type=&quot;math/tex&quot;&gt; \Theta (2 + \frac{\alpha}{2} - \frac{\alpha}{2n}) = \Theta (1 + \alpha) &lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section-2&quot;&gt;开放寻址法&lt;/h3&gt;
&lt;p&gt;在开放寻址法中，对于每一个关键字k，定义探查序列
    &amp;lt;h(k, 0), h(k, 1),&amp;#8230;, h(k, m-1)&amp;gt;
是&amp;lt;0, 1, &amp;#8230;, m-1&amp;gt;的一个排列。在插入某一个元素x时，如果它的关键字是k,
按照它所对应的探查序列从h(k, 0)到h(k, m-1)依次检查散列表，如果h(k,i)是空槽，
那么将x插入到这个槽，否则检查h(k, i+1)。在查找时，
也是沿着探查序列开始寻找。&lt;/p&gt;

&lt;p&gt;探查序列的计算方法有很多，比如说线性探查法，二次探查法，双重散列法。
但是这些技术都不能保证一致散列的假设：
对于每一个关键字k, &amp;lt;h(k, 0), h(k, 1),&amp;#8230;, h(k, m-1)&amp;gt;是&amp;lt;0, 1, &amp;#8230;, m-1&amp;gt;的任何一种排列的可能性是相同的。&lt;/p&gt;

&lt;p&gt;在一致散列的假设下，有如下性质成立：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于装载因子为&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 \alpha = n/m &lt; 1  %]]&gt;&lt;/script&gt;的开放散列表，查找一个不存在的元素所需的探查数期望至多为&lt;script type=&quot;math/tex&quot;&gt; \frac{1}{1-\alpha} &lt;/script&gt;&lt;/p&gt;

    &lt;p&gt;定义随机变量X为探查数，&lt;script type=&quot;math/tex&quot;&gt; A_i &lt;/script&gt;为进行了第i次探查，有:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

 \begin{array} {lcl}
     E[X] &amp;=&amp; \sum_{i=1}^{\infty} i \bullet Pr\{X = i\} \\
            &amp;=&amp; (Pr\{X=1\} + Pr\{X=2\} + ...) + (Pr\{X=2\} + Pr\{X=3\} + ...) + ... \\
            &amp;=&amp; \sum_{i=1}^{\infty}Pr\{ X \geq i \} \\
     Pr\{ X \geq i \} &amp;=&amp; Pr\{ A_1 \bigcap A_2 \bigcap ... \bigcap A_{i-1} \} \\
         &amp;=&amp; Pr\{A_1\} \bullet Pr\{ A_2 | A_1 \} \bullet ... \bullet Pr\{ A_{i-1} | A_1 \bigcap A_2 \bigcap ... \bigcap A_{i-2} \} \\
     Pr\{ A_1 \} &amp;=&amp; \frac{n}{m} = \alpha \\
     Pr\{ A_j | A_1 \bigcap A_2 \bigcap ... \bigcap A_{j-1} \} &amp;=&amp; \frac{n-j+1}{m-j+1} \leq \frac{n}{m} = \alpha \\
     Pr\{X \geq i \} &amp;=&amp; \frac{n}{m} \bullet \frac{n-1}{m-1} \bullet \frac{n-2}{m-2} \bullet ... \bullet \frac{n-i+2}{m-i+2}
         \leq (\frac{n}{m})^{i-1} = \alpha^{i-1} \\
     E[X] &amp;=&amp; \sum_{i=1}^{\infty}Pr\{ X \geq i \} \leq \sum_{i=1}^{\infty} \alpha^{i-1}
         = \sum_{i=1}^{\infty} \alpha^{i-1} = \frac{1}{1-\alpha}
 \end{array}
  %]]&gt;&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向一个装载因子为&lt;script type=&quot;math/tex&quot;&gt; \alpha &lt;/script&gt;的开放寻址散列表中插入一个元素，平均情况下最多进行&lt;script type=&quot;math/tex&quot;&gt; \frac{1}{1-\alpha} &lt;/script&gt;次探查。&lt;/p&gt;

    &lt;p&gt;因为要插入一个元素x，只需要做一次查找x就能找到一个空槽，所以探查次数与查找一个不存在元素的查找相同。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个装载因子为&lt;script type=&quot;math/tex&quot;&gt; \alpha &lt;/script&gt;的开放散列表中查找一个存在的元素的期望探查次数至多为&lt;script type=&quot;math/tex&quot;&gt; \frac{1}{\alpha} \ln \frac{1}{1-\alpha} &lt;/script&gt;&lt;/p&gt;

    &lt;p&gt;对于每一个元素x，查找它所需要的探查次数与插入它所需要的探查次数相同，
 对于第i个插入的元素x, 所需的探查次数最多为&lt;script type=&quot;math/tex&quot;&gt; \frac{1}{1-\frac{i}{m}} = \frac{m}{m-i} &lt;/script&gt;，
 所以平均的探查次数最多为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
 \frac{1}{n} \sum_{i=0}^{n-1} \frac{m}{m-i} = \frac{m}{n} \sum_{i=0}^{n-1}\frac{1}{m-i}
     \leq \frac{1}{\alpha} \ln \frac{1}{1-\alpha}
 &lt;/script&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对比开放寻址法与链接法，链接法能够支持装载因子&lt;script type=&quot;math/tex&quot;&gt; \alpha &gt; 1 &lt;/script&gt;的情况，
而开放寻址法不能支持。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;二叉查找树与红黑树&lt;/h2&gt;
&lt;p&gt;二叉查找树和红黑数都是用来存储动态集合的数据结构，
红黑树对二叉查找树进行了扩展，通过一些额外的性质，
保证了二叉查找树的平衡性，
这样就能够保证树的高度为O(lgn)， 其中n是节点的个数。
有了这些额外的性质时，
在插入节点或者删除节点的时候就需要一些额外的操作来保持这些性质。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;二叉查找树的基本操作&lt;/h3&gt;
&lt;p&gt;二叉查找树所支持的基本操作有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查找。
因为在二叉查找树中， 对于任何一个节点，
左子树中的关键字都小于当前节点的关键字，
而右子树中的关键字都大于当前节点的关键字，
所以可以通过一个简单的递归的来查找一个关键字：
如果关键字大于当前关键字，则递归查询右子树，
否则如果关键字小于当前关键字，递归查询左子树。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插入。插入也可以通过简单的递归来实现：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;如果要插入的关键字大于当前的关键字，如果右子树为空，
 则把这个节点作为当前节点的右儿子，否则递归插入到右子树&lt;/li&gt;
      &lt;li&gt;如果要插入的关键字小于当前的关键字，如果左子树为空，
 则把这个节点作为当前节点的左儿子，否则递归插入到左子树&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;寻找二叉查找树中的最小节点和最大节点。
这两个操作是对称的，只需要给出求最小节点的方法，
采用递归的方式实现：
    &lt;ul&gt;
      &lt;li&gt;如果左子树非空，则返回左子树中的最小节点&lt;/li&gt;
      &lt;li&gt;否则返回当前节点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;寻找节点x的直接前趋或者直接后继。
这两个操作是对称的，只需要给出寻找直接后继的方法：
节点x的直接后继是指关键字大于key[x]中最小的那个节点，
    &lt;ul&gt;
      &lt;li&gt;如果x的右儿子存在，那么后继在x的右子树中，
 以x的右子树中的最小节点就是x的直接后继&lt;/li&gt;
      &lt;li&gt;如果x的右儿子不存在，那么需要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;删除。在删除一个节点x的时候，有三种情况需要考虑：
    &lt;ul&gt;
      &lt;li&gt;如果要删除的节点是叶节点，直接删除即可。&lt;/li&gt;
      &lt;li&gt;如果要删除的节点只有一个儿子，那么先建立它的祖先和它儿子的父子关系,
 然后把它删除。&lt;/li&gt;
      &lt;li&gt;如果要删除的节点有两个儿子，那么先从它的右子树中找到x的直接后继节点y，
 此时y一定没有左儿子（因为如果y有左儿子的话左儿子一定大于x且小于y，
 与y是x的直接后继矛盾）, 所以可以把y先从树中移除(删除y一定属于前两种情况)，
 然后用y代替x的位置。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-5&quot;&gt;红黑树的性质&lt;/h3&gt;
&lt;p&gt;相对于二叉查找树来说，赋予了每一个节点红色或者黑色，
同时整个红黑树需要保持下面的性质：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;每个节点或者是红的，或者是黑的&lt;/li&gt;
  &lt;li&gt;根节点是黑的&lt;/li&gt;
  &lt;li&gt;每个叶节点是黑的&lt;/li&gt;
  &lt;li&gt;如果一个节点是红的，那么它的两个儿子必须是黑的&lt;/li&gt;
  &lt;li&gt;对每一个节点，从该节点到叶节点的所有路径上包含相同数目的黑节点&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其中，性质3可以不用考虑，因为在红黑树中，
所有的叶节点都是NIL, 它永远都是黑色。&lt;/p&gt;

&lt;p&gt;有了这几条性质之后，
能保证一棵有n个节点（不包括NIL叶节点）的红黑树高度至多为2lg(n+1)。
这时，查找操作能够在O(lgn)的时间内完成。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;在插入和删除时红黑树性质的保持&lt;/h3&gt;
&lt;p&gt;红黑树的性质可能在插入或者删除节点的时候被破坏，
此时需要一些操作来维护红黑数的性质。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;插入&lt;/h4&gt;
&lt;p&gt;插入一个节点时，始终把新插入的节点的设成红色，
这时，会有两种原因造成红黑树性质的破坏：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果新插入的节点是根节点，那么会破坏性质2&lt;/li&gt;
  &lt;li&gt;如果插入节点的父节点是红色，那么将会破坏性质4&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数RB-INSERT_FIX_UP()用于在插入z时红黑树T性质的保持：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def RB-INSERT-FIXUP (T, z):
    while color[p[z]] = RED
        do if p[z] = left[p[p[z]]]
            then y ← right[p[p[z]]]
            if color[y] = RED                   
                then color[p[z]] ← BLACK        ###case1
                color[y] ← BLACK                ###case1
                color[p[p[z]]] ← RED            ###case1
                z ← p[p[z]]                     ###case1
            else if z = right[p[z]]            
                    then z ← p[z]               ###case2
                    LEFT-ROTATE (T, z)          ###case2
                color[p[z]] ← BLACK             ###case3
                color[p[ p[z]]] ← RED           ###case3
                RIGHT-ROTATE (T, p[p[z]])       ###case3
        else (same as then clause
            with “right” and “left” exchanged)
    color[root[T]] ← BLACK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数能达到目的因为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果是上面的原因1违反, 那么p[z]是黑色，不会进入循环，直接在最后一行把根节点设为黑色&lt;/li&gt;
  &lt;li&gt;如果是原因2违反，情况就要复杂一些，不能简单地把当前节点或者其父节点设为黑色就能解决问题，
因为此时可能会导致从根到各个叶节点路径上黑节点数目不相等（经过z的个数多1）。在这种情况下，
就要想办法把性质4的不一致向根节点“传递”，因为如果这种不一致到了根节点，
直接把根节点设为红色就可以，而不会引起其他的问题, 代码中分了三种情况：
    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;如果是情况1，p[z]和z的叔叔都是红色，可以把p[z]和y(z的叔叔)都设为黑色，
 然后把p[p[z]]设为红色，这样就把这种红红的不一致向上传递了两层，
 这种不一致在向上传递的过程中会有三种情况：&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;没有造成不一致， 因为虽然把newz = p[p[z]]设为了红色，但可能此时p[newz]也是黑色，没有违反性质4&lt;/li&gt;
          &lt;li&gt;造成不一致然后遇到了情况1， 这时会把这种不一致继续向上传递&lt;/li&gt;
          &lt;li&gt;造成不一致然后遇到了情况2，3，这时直接可以通过旋转和颜色调整解决，不用向上传递&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;无论是哪一种情况，要么会被解决，要么传递到根由根来解决。&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;如果是情况2，3，这时可以通过旋转和重新着色解决性质4的不一致，而不会造成其他问题。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-8&quot;&gt;删除&lt;/h4&gt;
&lt;p&gt;在删除一个节点时，如果被删除的节点是红色，
那么不会有问题，因为它的儿子和父亲都是黑色，
不会违背性质4，
同时任何路径上的黑色节点的个数也不会发生变化。
但如果删除的是一个黑色的节点y，会有以下原因导致性质违背：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果y是根节点，而y的红色儿子成为了新的根，会违背性质2&lt;/li&gt;
  &lt;li&gt;如果y的儿子x(y最多有一个儿子，可以从二叉查找树的删除中得到这个结论)和父亲都是红色，
那么会违背性质4&lt;/li&gt;
  &lt;li&gt;删除y会导致经过y的路径上的黑节点数目个数少1，违背性质5&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;函数RB-DELETE-FIXUP()用于在删除节点x的父亲时性质维护：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def RB-DELETE-FIXUP(T, x):
    while x != root[T] and color[x] = BLACK
        do if x = left[p[x]]
            then w ← right[p[x]]
            if color[w] = RED
                then color[w] ← BLACK                                  ###case1
                color[p[x]] ← RED                                      ###case1
                LEFT-ROTATE (T, p[x])                                  ###case1
                w ← right[p[x]]                                        ###case1
            if color[left[w]] = BLACK and color[right[w]] = BLACK
                then color[w] ← RED                                    ###case2
                x ← p[x]                                               ###case2
            else if color[right[w]] = BLACK
                    then color[left[w]] ← BLACK                        ###case3
                    color[w] ← RED                                     ###case3
                    RIGHT-ROTATE (T, w)                                ###case3
                    w ← right[p[x]]                                    ###case3
                color[w] ← color[p[x]]                                 ###case4
                color[p[x]] ← BLACK                                    ###case4
                color[right[w]] ← BLACK                                ###case4
                LEFT-ROTATE (T, p[x])                                  ###case4
                x ← root[T]                                            ###case4
        else (same as then clause with “right” and “left” exchanged)
    color[x] ← BLACK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从代码中可以看出，原因1或者原因2都没有进入循环，直接通过把x设为黑色就能解决问题。
解决原因3的基本思路是给x赋予一层多余的黑色(充当一个黑色节点的计数)，试着把这个多余的黑色往根传递, 
在向上传递的过程中，可能会遇到3种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这种多余的黑色传递到了一个红色的节点，那么直接把这个红色的节点设为黑色即可&lt;/li&gt;
  &lt;li&gt;在传递过程中遇到了情况3，4，可以通过旋转和颜色调整而解决问题，不会引起其他的问题&lt;/li&gt;
  &lt;li&gt;一直遇到情况2而传递到了根节点，这时直接去掉这个多余的黑色即可，
因为此时从根到叶节点的所有路径的黑节点数目都少1，性质5得到解决。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为什么再调整过程中旋转的次数不超过3次？简单看来，有如下转换关系：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;case1 -&amp;gt; case2, case3, case4,情况1结束之后将到达情况2，或情况3，或情况4&lt;/li&gt;
  &lt;li&gt;case2 -&amp;gt; new while, 情况2之后将进入新的循环&lt;/li&gt;
  &lt;li&gt;case3 -&amp;gt; case4，情况3将到达情况4&lt;/li&gt;
  &lt;li&gt;case4 -&amp;gt; 终止，情况4之后把x设为root，将导致循环终止&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;情况1会有旋转，如果进入了情况3或情况4，将导致循环终止，此时旋转次数不超过3次，
但如果进入进入情况2，那么将会进入新的循环，此时有可能碰到情况1然后再次旋转，
然后进入再进入情况2&amp;#8230;这样一直向上到根，旋转的次数可能会超过3次，
是这样吗？&lt;/p&gt;

&lt;p&gt;上面的情况的是不可能发生的，因为情况1会把p[x]设为红色，如果此时进入情况2，
在新的循环开始时，新的x就是p[x]，它的颜色是红色，直接会退出循环，把x设为黑色，
调整结束，不会再继续向上传递。所以旋转的次数不会超过3次。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>算法导论8~9章读书笔记</title>
   <link href="http://username.github.com/clrs/2012/12/01/clrs-8-9"/>
   <updated>2012-12-01T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/12/01/clrs-8-9</id>
   <content type="html">&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;--&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/custom/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h3 id=&quot;section&quot;&gt;比较排序的时间下界&lt;/h3&gt;
&lt;p&gt;合并排序和堆排序在最坏情况下能够在O(nlgn)时间内排序n个数，
而快速排序则能够在平均情况下达到这个上界。
这些算法在确定元素的次序时，
都是基于元素间的比较。
这类排序算法称为&lt;strong&gt;比较排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比较排序的时间下界是O(nlgn)，
这意味着所有的基于比较的排序算法，在最坏情况下都要用&lt;script type=&quot;math/tex&quot;&gt; \Omega (n \lg n) &lt;/script&gt;
次比较来完成排序。&lt;/p&gt;

&lt;p&gt;这是因为比较排序可以被抽象为&lt;strong&gt;决策树&lt;/strong&gt;，
决策树是一棵满二叉数，
它的每一条从根节点到叶节点的路径都对应于比较排序的一次执行过程，
达到叶节点时，叶节点确定了这次排序的结果。
所以比较排序算法的最坏情况的比较次数等于决策树的高度。
n个数的排列总数有n!，每一种排列都必须在决策树的叶节点中出现，
高度为h的决策树的叶节点个数最多为&lt;script type=&quot;math/tex&quot;&gt; 2^h &lt;/script&gt;，故有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
n! \leq 2^h \\
\Longrightarrow   h \geq \lg (n!) = \Omega (n \lg n)
&lt;/script&gt;

&lt;p&gt;所以比较排序的时间下界是O(nlgn)。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通过计数排序实现线性时间排序&lt;/h3&gt;
&lt;p&gt;如果已经知道n个元素都是来自于0到k的整数，
其中&lt;script type=&quot;math/tex&quot;&gt; k = O(n) &lt;/script&gt;,
那么可以通过统计0到k中的每一个数在n个元素中出现的次数来达到排序的目的。
计数排序的运行时间为 &lt;script type=&quot;math/tex&quot;&gt; \Theta (n) &lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;书上在实现计数排序时，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先遍历一遍原数组A，将各个元素出现次数统计到数组C中,此时C[0..k]的每一项C[i]表示i在A中的出现次数&lt;/li&gt;
  &lt;li&gt;然后遍历一遍数组C, 使C[i]表示A中小于或等于i的元素个数&lt;/li&gt;
  &lt;li&gt;最后遍历A(逆向遍历)，把结果放到数组B中，把A[i]放到B的C[A[i]]位置上，同时把C[A[i]]减1
(这是为了把重复的元素放到不同的位置上去)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实只需要让C[i]记录i在数组A中出现的次数，然后遍历一遍数组C就可以输出排序的结果。
具体遍历方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;j &amp;lt;- 1
for i &amp;lt;- 1 to k
    while C[i] &amp;gt; 0
        do C[i] &amp;lt;- C[i] - 1 
            A[j] = i
            j &amp;lt;- j + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就能把排序好的结果保存到A中，不需要另外的数组B。
但是书上的这种方法有一个好处，它能保证排序是&lt;strong&gt;稳定&lt;/strong&gt;的。
也就是说，具有相同值的元素在输出数组中的相对次序与输入数组中的相对次序一样。
因为是采取对A的逆向遍历，两个相同的元素中，位置靠前的元素后被遍历，此时C[i]已经变小了，
所以也会被放在更靠前的位置。稳定排序的好处在于它能够保证基数排序的正确性。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基数排序：另一种线性时间排序&lt;/h3&gt;
&lt;p&gt;基数排序主要解决的问题是对于多位整数的排序问题。
比如有n个d位数，每一位可以取k个不同的值，要对它进行排序，
一般的想法是先对最高位进行排序，
然后对于高位相同的子数组按次高位进行排序，依次类推。
这种想法的好处在于如果两个数中高位较大的数一定较大，
所以很容易把各个子数组的排序结果进行合并。比如排序10进制的三位数，
3XX一定都大于2XX，所以把2XX的子数组放在3XX的子数组前面就能保证合并结果的有序性。
但是它的不好的地方在于需要维护大量的子数组(随着递归的深度加深，子数组个数增多)，
这对于原始的基于纸带的排序的是不可行的。&lt;/p&gt;

&lt;p&gt;那有没有一种排序方法，既能使后面的排序利用到前面排序的结果，
而且能够不需要维护大量的子数组呢？基数排序就是这样一种排序方法，
它先把数组按最低位进行排序，然后再对结果按次低位进行排序，依次类推。
每一次的排序都必须是&lt;strong&gt;稳定排序&lt;/strong&gt;，这样能保证在按某位进行排序之后，
整个数组在从该位到最低位的子序列上都是有序的，可以通过一个简单的归纳加以证明。&lt;/p&gt;

&lt;p&gt;同时，在对n个b位数进行排序时，每次可以按r位进行排序，
而不仅仅是1位，这样能够在&lt;script type=&quot;math/tex&quot;&gt; \Omega ((b/r)(n + 2^r)) &lt;/script&gt;的时间内完成对数组的排序。
可以选取适当的r达到最好的时间性能。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;同时找出数组中的最大值和最小值&lt;/h3&gt;
&lt;p&gt;从一个数组中找出最大值或者最小值需要n-1次比较，
比如寻找最大值，首先将最大值设为第一个元素的值，
然后让n-1个元素和最大值进行比较，如果大于最大值，
就将最大值设为它，一共需要n-1次比较。&lt;/p&gt;

&lt;p&gt;而如果是同时找出最大值和最小值呢，
当然可以分别按上面的方法找出最大值和最小值，
一共需要的比较次数是2n-2。&lt;/p&gt;

&lt;p&gt;书上给出了另外一种方法：
成对的处理元素，将较小者与最小值相比，较大者与最大值相比，
这样能将比较次数降为&lt;script type=&quot;math/tex&quot;&gt;  3 \lceil n/2 \rceil &lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;i&quot;&gt;在线性时间内选出数组中的第i小元素&lt;/h3&gt;
&lt;p&gt;书上给出了两种方法：&lt;/p&gt;

&lt;p&gt;第一种方法利用随机化快速排序算法中的RANDOMIZED-PARTITION函数对数组进行划分，然后根据
i是在哪一个部分中去相应部分中进行查找，这种方法能保证运行时间的期望是线性，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def RANDOMIZED-SELECT(A, p, r, i)
    q &amp;lt;- RANDOMIZED-PARTITION(A, p, r)
    k &amp;lt;- q - p + 1
    if i = k
        then return A[q]
    elseif i &amp;lt; k
        then return RANDOMIZED-SELECT(A, p, q-1, i)
    else return RANDOMIZED-SELECT(A, q+1, r, i-k)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说明一下在划分的两个子数组中，如果有一个长度为0，
为什么不会它调用RANDOMIZED-SELECT:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果子数组A[p..q-1]长度为0，则q = p，k = q - p + 1 = 1，&lt;script type=&quot;math/tex&quot;&gt; i \geq k &lt;/script&gt;, 不会对这个子数组调用RANDOMIZED-SELECT&lt;/li&gt;
  &lt;li&gt;如果子数组A[q+1..r]长度为0，则q = r，k = r - p + 1 = length[A]，&lt;script type=&quot;math/tex&quot;&gt; i \leq k &lt;/script&gt;, 不会对这个子数组调用RANDOMIZED-SELECT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种方法通过保证每次的划分是一个好的划分保证算法的线性时间。
具体的划分方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将数组的n个元素划分为 &lt;script type=&quot;math/tex&quot;&gt; \lceil n/5 \rceil &lt;/script&gt;组，除最后一组之外，其余都有5个元素&lt;/li&gt;
  &lt;li&gt;对每一组找到其中位数, 首先对每个数组进行插入排序，然后找到其中的中位数&lt;/li&gt;
  &lt;li&gt;通过递归调用SELECT函数(就是找出数组中第i小元素的函数)，找到这些中位数中的中位数x&lt;/li&gt;
  &lt;li&gt;以x作为划分元素对数组进行划分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个划分是一个好的划分，
因为能保证划分出来的两个子数组中任意一个的长度都不会超过某一个特定值。
在&lt;script type=&quot;math/tex&quot;&gt; \lceil n/5 \rceil &lt;/script&gt;个组中，
假设所有的中位数组成数组B[1..m]，其中 &lt;script type=&quot;math/tex&quot;&gt; m = \lceil n/5 \rceil &lt;/script&gt;,
假设x = B[k]，k = &lt;script type=&quot;math/tex&quot;&gt; \lceil \frac{1}{2} \lceil \frac{n}{5} \rceil \rceil &lt;/script&gt;,
在所有中位数在A[k..m]的组中，除去最后一组和x所在的组之外，其他的组至少有3个元素大于x，
所以大于x的元素个数至少为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
3(\lceil \frac{1}{2} \lceil \frac{n}{5} \rceil \rceil - 2) \geq \frac{3n}{10} - 6
&lt;/script&gt;

&lt;p&gt;类似的小于x的元素个数至少有&lt;script type=&quot;math/tex&quot;&gt; \frac{3n}{10} - 6 &lt;/script&gt;个，
所以至多有&lt;script type=&quot;math/tex&quot;&gt; \frac{7n}{10} + 6 &lt;/script&gt;个元素被递归的调用SELECT，
有了这个结论之后就能保证SELECT函数可以在线性的时间内完成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《算法导论》读书总结1</title>
   <link href="http://username.github.com/clrs/2012/11/19/clrs-1"/>
   <updated>2012-11-19T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/11/19/clrs-1</id>
   <content type="html">&lt;!--&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;--&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;/assets/custom/MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;p&gt;正如上一篇所说，我这几天都在学习《算法导论》这本书，
也终于是下定决心要好好把这本书看出个所以然来。
这几天看下来，发现最大的困扰并不是知识的难度，
而是克服自己内心的浮躁。因为这本书并不像其他的工科教材，
它讲得东西是比较偏理论一些，里面充满了各种数学公式，数学定理,
包括一个算法正确性的证明，都采取了形式化的证明手段，
力求证明的数学严格性。
如果只是需要粗粗理解各种算法是什么样的以及如何实现的话，
那么看这本书有点不太合适，
因为这方面的东西并不是这本书的重点。&lt;/p&gt;

&lt;p&gt;而我，也是在粗粗了解了各种算法和实现的基础上学习这本书的，
一开始扫了一下书的第一章，第二章和第六章，
发现和其他的算法书还差不多嘛，
直到看到第七章快速排序，
看到作者在大概描述完快速排序算法之后
（这个快速排序的划分函数还和我以前见过的都不一样，更加容易理解和实现），
转而开始分析快速排序的性能和随机化版本，我才明白，
我不能再这么浮躁地只是抱着了解了解算法的目的来学习这本书了。
于是我又回过去仔仔细细地从头看到了第7章，
虽然说这本书里的定理和数学公式很多，但是并不难理解，
因为作者总是把每一个步骤解释地十分细致和透彻，
每一步的证明没有很大的跨越，
每一个结论的得出都会指明依据的定理或者是前面的结论。
所以说好好看下去其实并没有很大难度，
关键是要能够静得下心。&lt;/p&gt;

&lt;p&gt;下面是1～7章中我的几点体会：&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;循环不变式&lt;/h3&gt;
&lt;p&gt;循环不变式用于证明算法的正确性，
它能够保证一个算法能够终止，
而且当它终止时，得到的结果是正确的结果。
循环不变式的证明由三个部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化: 在循环的开始时，循环不变式成立。&lt;/li&gt;
  &lt;li&gt;保持：如果在某一轮迭代之前循环不变式成立，那么在迭代之后，
循环不变式仍然成立。&lt;/li&gt;
  &lt;li&gt;终止：如果保持循环不变式一直到循环的终止，那么这个算法将得到正确的结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;循环不变式与数学归纳法十分类似，采用的也是同样的思想。
在应用循环不变式对算法的正确性进行证明时，
难点不在于上述的三个步骤，而在于循环不变式的构造，
要构造一个循环不变式能够在循环过程中始终保持，
而且能体现算法正确性，这确实需要一定的技巧。
这就类似于在应用数学归纳法时选取归纳条件。&lt;/p&gt;

&lt;p&gt;比如书中思考题2-2：（证明冒泡排序的正确性）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i &amp;lt;- 1 to length[A]
    do for j &amp;lt;- length[A] downto i+1
        do if A[j] &amp;lt; A[j-1]
            then exchange A[j] &amp;lt;-&amp;gt; A[j-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b)对于2-4行(内层循环)给出一个循环不变式，并证明这个循环不变式是成立的。&lt;/p&gt;

&lt;p&gt;内层循环的作用是把A[i]到A[n]（n是length[A]）中最小元素放到A[i],
可以采用如下的循环不变式来表示：&lt;/p&gt;

&lt;p&gt;在每一轮迭代的开始，子数组A[j..n]中最小的元素位于A[j]。&lt;/p&gt;

&lt;p&gt;下面对这个循环不变式进行证明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化： 在第一轮迭代开始前，j = n，A[j..n]中就只有一个元素，
最小的元素位于A[n]。&lt;/li&gt;
  &lt;li&gt;保持：在第k轮迭代时，
    &lt;ul&gt;
      &lt;li&gt;如果A[j] &amp;gt;= A[j-1]，由循环不变式可知，
A[j]是字数组A[j..n]中最小的元素，那么循环结束时A[j-1]将是字数组A[j-1..n]中的最小元素。&lt;/li&gt;
      &lt;li&gt;如果A[j] &amp;lt; A[j-1], 那么在互换A[j]和A[j-1]之后，最小的元素仍然是A[j-1]。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;终止: 在循环结束时j=i, 说明A[i]是字数组A[i..n]中的最小元素，
算法达到了把最小元素放到A[i]的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;渐进符号&lt;/h3&gt;
&lt;p&gt;渐进符号用户描述一个算法的复杂度，以前只知道
渐进符号用于描述算法的量级，比如&lt;script type=&quot;math/tex&quot;&gt; 2n^2 = O(n^2) &lt;/script&gt; 
说明 
&lt;script type=&quot;math/tex&quot;&gt; 2n^2 &lt;/script&gt;
的量级是
&lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;书上给出了准确的定义:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
O(g(n)) = \{f(n): \exists c,n， \forall n \geq n_0,  0 \leq f(n) \leq cg(n)\}
&lt;/script&gt;

&lt;p&gt;同时有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f(n) = O(g(n)) \Longleftrightarrow f(n) \in O(g(n)) 
&lt;/script&gt;

&lt;p&gt;其他的符号如&lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\Theta &lt;/script&gt;都是类似的定义。
当然，我们只需要知道用&lt;script type=&quot;math/tex&quot;&gt; O(f(n)) &lt;/script&gt;来确定一个函数的上界，
用&lt;script type=&quot;math/tex&quot;&gt; \Omega(f(n)) &lt;/script&gt;来确定一个函数的下界就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;递归与主定理&lt;/h3&gt;
&lt;p&gt;分治法是一种很常见的算法设计方法，
分治法的时间复杂度一般由如下的递归式给出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
T(n) = aT(n/b) + f(n)
&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt; a \geq 1, b &gt; 1&lt;/script&gt;，f(n)一般用渐进函数表示。&lt;/p&gt;

&lt;p&gt;对于这样的递归式，主定理给出了计算T(n)的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果存在常数&lt;script type=&quot;math/tex&quot;&gt; \epsilon &gt; 0 &lt;/script&gt;，有
&lt;script type=&quot;math/tex&quot;&gt; f(n) = O(n^{\log_ba - \epsilon}) &lt;/script&gt;，
则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(n^{\log_ba}) &lt;/script&gt;;&lt;/li&gt;
  &lt;li&gt;如果
&lt;script type=&quot;math/tex&quot;&gt; f(n) = \Theta(n^{\log_ba}) &lt;/script&gt;，
则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(n^{\log_ba}\lg n) &lt;/script&gt;;&lt;/li&gt;
  &lt;li&gt;如果存在常数&lt;script type=&quot;math/tex&quot;&gt; \epsilon &gt; 0 &lt;/script&gt;，有
&lt;script type=&quot;math/tex&quot;&gt; f(n) = \Omega(n^{\log_ba + \epsilon}) &lt;/script&gt;，
且对常数&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 c &lt; 1  %]]&gt;&lt;/script&gt;与足够大的n,有
&lt;script type=&quot;math/tex&quot;&gt; af(n/b) \leq cf(n) &lt;/script&gt;，则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(f(n)) &lt;/script&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运用主定理，能够很快地求出分治算法的复杂度。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;指示器随机变量&lt;/h3&gt;
&lt;p&gt;指示器随机变量的定义如下:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
 
    X_H = I\{H\} = 
     \begin{cases}
         1 &amp; \text{如果H发生} \\
         0 &amp; \text{如果H没有发生}
     \end{cases}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;指示器随机变量是随机变量的一种，可以求出它的期望如下：
$$
    E[X_H] = Pr_H
$$&lt;/p&gt;

&lt;p&gt;指示器随机变量有一个很好的性质，它只能取0或者1，
可以把它这些变量加起来求总的发生次数,
因此当它应用到重复随机试验中时,
统计重复试验某一事件发生次数的期望，
比如在随机化的快速排序中统计交换次数的期望,
可以通过如下公式得到：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; 
E[X] = E[\sum_{i=1}^n X_i] = \sum_{i=1}^n E[X_i]
&lt;/script&gt;

&lt;p&gt;要使等式的第二步成立，不一定要保证&lt;script type=&quot;math/tex&quot;&gt; X_i &lt;/script&gt;之间是相互独立的。&lt;/p&gt;

&lt;p&gt;这周的读书笔记就先写到这里，下周开始写第8章开始的内容。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL 基本优化</title>
   <link href="http://username.github.com/mysql/2012/11/15/mysql-basic"/>
   <updated>2012-11-15T00:00:00+08:00</updated>
   <id>http://username.github.com/mysql/2012/11/15/mysql-basic</id>
   <content type="html">
&lt;p&gt;这几天好好地研究了一下mysql,认真地看了《High Performance MySQL》的几章，
才发现，要能够精通mysql真的是一个长期的工程，有效地管理mysql,
使它能够具有很强的稳定性同时具有很快的相应速度，
这其中涉及的东西远远不是数据库的课上写几条sql语句那么简单。
而在这篇博客中，我也仅就mysql的一些基本优化知识谈谈我的看法，
待以后更加深入研究之后，再继续分享。&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL的表的设计&lt;/h2&gt;

&lt;h3 id=&quot;normalized-schema-or-denormalized-schema&quot;&gt;Normalized Schema Or Denormalized Schema?&lt;/h3&gt;
&lt;p&gt;在一般的数据库教材中，讲到设计库表结构的设计，
都是将数据库设计范式作为设计的准则，因为这样设计的数据库表重复很少，
这样就会减少存储空间，
同时因为重复的内容少，维护起来也很方便，
因为如果很多的重复的话一个信息的更改可能会需要在多处进行更改才能保证数据的一致性。
然而，数据库范式并不是万能的，这样设计出来的数据库会造成查找时间的加长，
因为要查找一些数据往往需要将多个表join起来，而join是比较费时间的数据库操作，
同时，一些有关系的列被分散到各个表中，不好组合在一起建成一个索引，
这样也会减低查找的速度。
所以在设计数据库的表的结构时，要结合应用的实际情况，平衡考虑。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;cache-table--summary-table&quot;&gt;Cache Table &amp;amp; Summary Table&lt;/h3&gt;
&lt;p&gt;使用“空间换取时间”的理念，在数据统计的过程中，为了方便同时，
我们会建立一些缓存表，
这些表的目的是把一个表中的多行信息或者多个表的信息综合起来，
比如有一个表保存了今天的用户访问记录，
就可以建成一个daycount表统计每天有多少用户访问，
这样如果需要查询某一天有多少用户访问的时候直接去这个表中去查了。
缓存表引入的一个问题是缓存表的维护，
一般是通过一些周期性跑的脚本去更新这些缓存表，
FlexView这个工具能够自动的帮我们维护这些缓存表，
有兴趣的可以尝试一下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;数据类型的选择&lt;/h3&gt;
&lt;p&gt;尽量选择小的，简单的数据类型，能用tinyint就不要用int,能有enum就不要用varchar。
同时尽量不要用NULL，因为NULL会引入许多的问题，首先是它不容易被索引，
同时保存它占用了更多的空间。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;索引优化总结&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;为什么索引能够提高查找的速度？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;索引能够减少需要数据库需要读取的数据。因为它不需要整个表都读取一遍，
同时如果使用了覆盖索引，那么需要的数据就在索引中，只要将索引的数据返回即可。&lt;/li&gt;
  &lt;li&gt;索引能够帮助数据库进行排序。如果要排序的字段刚好在索引中，
由于索引本身就是排好序的，这样就不需要再进行排序，减少了时间和空间的浪费。&lt;/li&gt;
  &lt;li&gt;索引能够把随机IO转化为顺序IO，这是因为索引靠近的数据一般存储的位置也是相邻的，
这样能够顺序读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;多字段索引时顺序的选择&lt;/h3&gt;
&lt;p&gt;有时，建立索引一个字段的索引往往就够用了，因为通过这一个字段，就能过滤掉大部分的行，
剩下来的行数比较少，这样再进行过滤或者是sort, group等操作都不会有很大的压力。
然而，如果表中的数据非常多，一个字段过滤之后可能数据还是非常多，
这时就需要建立一个多字段的索引，又称为组合索引。&lt;/p&gt;

&lt;p&gt;组合索引的顺序选择非常重要，因为mysql只能拿一个索引的前缀进行索引。比如有一个索引
(col1, col2)，那么如果你的where语句中col1 = a and col2 = b或者是col1 = a，
这时mysql可以使用这个索引。但如果你的where语句是col2 = b这时就不能使用这个索引。
另外一个关乎索引顺序的地方是如果你的过滤条件是一个范围(range condition)的时候，再拿上面的索引为例，
如果你where语句有col1 = 1 and col2 &amp;lt; 2时，两个过滤的条件都会在使用索引过滤的时候起到作用，
而如果where语句是col1 &amp;gt; 1 and col2 = 2，这时只有第一个过滤条件在过滤索引时起到作用，也就是说，
在这时存储引擎会把col1 &amp;gt; 1的所有行都返回到mysql server，
而后服务器再通过col2 = 2过滤掉一些行，这个过滤的效果显然不好，
特别是当数据量较大的时候。关于这个的详细解释，
可以参考这篇&lt;a href=&quot;http://jorgenloland.blogspot.sg/2011/08/mysql-range-access-method-explained.html&quot;&gt;The MySQL range access method explained&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;既然索引的顺序这么重要，那如何去设计列的顺序呢？我总结了一些我的看法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A Rule of Thumb: 选择最具有过滤性列的放在索引的前面，因为这样的列能够很快地过滤掉
一些不需要的行。&lt;/li&gt;
  &lt;li&gt;把最经常拿来过滤的字段放在索引的前面，因为mysql使用的是前缀索引，
如果不经常使用的列放在前面会造成索引的失效。&lt;/li&gt;
  &lt;li&gt;把那些比较容易使用范围来进行过滤的字段放在索引后面，比如说day, created_at什么的。
因为如果这些字段放在前面会造成后面字段的过滤条件不起作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;explain&quot;&gt;理解explain语句&lt;/h3&gt;
&lt;p&gt;要知道一个索引设计得好不好，它有没有在sql语句中被合理地使用，
通过explain sql来查看sql一些执行细节是很有必要的。
explain sql的输出结果中，除了包含索引选择等信息，
还会告诉你诸如mysql如何对结果进行排序等信息。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weevilgenius.net/2010/09/mysql-explain-reference/&quot;&gt;MySQL Explain – Reference&lt;/a&gt;
这篇博客详细地讲述了explain语句输出的各个字段表示的意义，
特别是将type(access type)这个部分讲得特别清楚。&lt;/p&gt;

&lt;h2 id=&quot;sql&quot;&gt;优化SQL语句&lt;/h2&gt;
&lt;p&gt;设计好表的结构和索引之后，仍然需要采取适当的方式来进行查询才能达到更好的执行效率。
《High Performance MySQL》给出了几个优化的技巧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽量使用join来代替子查询语句，因为它能够更好地利用索引。&lt;/li&gt;
  &lt;li&gt;使用&amp;#8217;deferred join&amp;#8217;来优化limit offset,具体可参照《High Performance MySQL》的6.7.5节。&lt;/li&gt;
  &lt;li&gt;优化join:
    &lt;ul&gt;
      &lt;li&gt;确保被join的字段在第二个表中被索引&lt;/li&gt;
      &lt;li&gt;确保group by或者order by的字段在同一个表中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/&quot;&gt;Top 20+ MySQL Best Practices&lt;/a&gt;，
陈皓写了这篇的&lt;a href=&quot;http://coolshell.cn/articles/1846.html&quot;&gt;翻译版&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://isky000.com/database/mysql-performance-tuning-index&quot;&gt;MySQl 性能优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;预告&lt;/h2&gt;
&lt;p&gt;前两天&lt;a href=&quot;http://weibo.com/jeffz&quot;&gt;@老赵&lt;/a&gt;发起了一个资助大学生读书的计划，
我有幸得到了他资助的《算法导论》一本。
这样一本书并不是随便就能得来的，正如老赵所说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因此，千万不要把这个计划当做是免费的图书来源，选书要谨慎，拿到书就要好好阅读。
在我看来，参与这个计划其实更多的是压力。
当然，有适当的压力对于学习也是很有好处的，不是么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我，也正是需要这样的一种压力，能够督促我更好地去学习这样一本经典教材。
因此，接下来我会经常地在这里公布我的读书笔记，更多的是自己学习算法的心得体会，
希望能够多多有所感悟，学到更多的东西。:)&lt;/p&gt;

&lt;p&gt;特别感谢老赵的热心，能够让我们阅读这些经典的书籍，也希望他能够帮助更多的人。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浅谈中文编码</title>
   <link href="http://username.github.com/python/2012/11/11/chinese-encoding"/>
   <updated>2012-11-11T00:00:00+08:00</updated>
   <id>http://username.github.com/python/2012/11/11/chinese-encoding</id>
   <content type="html">
&lt;p&gt;作为一个天朝的程序员，总是会在编程的时候与中文打交道。一开始对于编码不是很熟悉，也没有弄明白它里面的原理，
在处理中文的时候总是会遇到各种各样的问题，特别是在用python处理中文的时候，
所以特地花时间研究了一下中文编码，并通过python来熟悉一些概念。&lt;/p&gt;

&lt;p&gt;废话不多说，先上干货，&lt;a href=&quot;http://www.searchtb.com/2012/04/chinese_encode.html&quot;&gt;中文编码杂谈&lt;/a&gt;，
这篇文章是淘宝搜索技术团队写的，深入浅出，基本上将中文编码的各个方面讲得十分细致，而且十分通俗易懂。
我很难讲得比这篇文章更好了，我主要从几个侧面来阐述一下我对于中文编码的理解。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;中文编码是什么&lt;/h2&gt;
&lt;p&gt;中文编码其实就是将中文转化为二进制比特串的过程，而不同的编码方式会把同一个中文字符转化为不同的二进制表示，
比如“中”这个字，通过utf-8编码会转化为二进制E4B8AD，而在计算机中，所有的数据都是通过二进制保存，这样我们就可以
通过二进制E4B8AD来保存“中”字，然后我们如果需要读取保存的这个字，我们首先需要知道编码方式是utf-8，然后就能将
E4B8AD转化为“中”。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;python的中文处理&lt;/h2&gt;
&lt;p&gt;python提供了对unicode很好的支持，同时也能将unicode转化为其他的各种编码。&lt;/p&gt;

&lt;p&gt;下面通过代码来对解释一下pytho中的编码问题。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;我是123&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xe6\x88\x91\xe6\x98\xaf&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;从上面的代码可以看到，python把&amp;#8221;我是123&amp;#8221;这个字符串当成是str类型，其实只是把这个字符串的编码
二进制当成中文来处理。当我们通过输入法输入&amp;#8221;我是123&amp;#8221;时，输入法会根据我们系统的LACALE值将&amp;#8221;我是123&amp;#8221;
编码成相应的二进制，而python遇到二进制值时的处理也是要根据系统的编码方式，如果是一个python的脚本，
我们可以通过再脚本的头部通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`# -*- coding:utf-8 -*- `
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置python处理编码的方式。&lt;/p&gt;

&lt;p&gt;同时可以看到&amp;#8221;我是123&amp;#8221;这个字符串的长度是9，这是因为字符串a在utf8编码时的二进制表示为&lt;code&gt;'\xe6\x88\x91\xe6\x98\xaf\x21\x22\x23'&lt;/code&gt;,
一共占了9个字节，python的len()函数对于字符串就是计算它占了多少个byte,所以:len(a) = 9。&lt;/p&gt;

&lt;p&gt;下面看如何与unicode进行相互转化:(此时采用的编码是utf8，其他的编码也是一样的处理):&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;u&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\u6211\u662f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;我是&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;unicode&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xe6\x88\x91\xe6\x98\xaf&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将字符串转换为unicode通过decode()函数，反过来通过encode()函数。同时也可以通过：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;unicode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;我是123&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;quot;我是123&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到同样的unicode。可以看到ua的长度为5，因为在unicode中不管是汉字还是字母或者是数字，
都当作同样的字符来进行处理，这样一个unicode的长度就是所有字符的个数，而不管这些字符是中文
汉字还是英文字符。这样的好处就在于能够很好地定位到一个具体的字符，字符串的截取以及正则表达式
匹配等操作都十分方便。所以推荐在处理包含中文的字符串时，先把这个字符串转化为unicode，然后再
进行操作，操作完以后再encode成字符串。&lt;/p&gt;

&lt;p&gt;关于中文编码就很浅显地谈到这里，希望能给大家带来帮助，有什么问题可以在留言中和我讨论。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>最近的总结与感悟</title>
   <link href="http://username.github.com/Feelings/2012/10/27/feeling"/>
   <updated>2012-10-27T00:00:00+08:00</updated>
   <id>http://username.github.com/Feelings/2012/10/27/feeling</id>
   <content type="html">

&lt;h2&gt;来由&lt;/h2&gt;

&lt;p&gt;这段时间真的很忙，忙得都没时间好好看书，好好写博客。&lt;/p&gt;

&lt;p&gt;每天都要上班，还要忙着保研的各种事情，有时还在保研和直接工作中纠结，
导致一有一点空闲时间，就什么事情也没想干了。&lt;/p&gt;

&lt;p&gt;还好，现在这些事情也终于告一段落，也不用再去纠结什么了，终于可以静下心来
去做自己喜欢做的事，踏踏实实地学习某些东西了。&lt;/p&gt;

&lt;p&gt;但是总结一番还是有点必要的，不然这些日子的纠结不是白费了吗。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h2&gt;我为什么选择读研&lt;/h2&gt;

&lt;p&gt;其实这个星期的前两天还在纠结当中，可是就好像砸中牛顿的那个苹果一样，
某种东西突然在我的头脑中闪现，让我顿悟，这个东西就是：梦想。&lt;/p&gt;

&lt;p&gt;梦想，别扯淡了，这年头谁还看中这个。&lt;/p&gt;

&lt;p&gt;我看中，我认为一个人一旦失去了梦想，活着也就没有什么意思了。
能支持一个人不断向前，不断超越自己的动力，也只有梦想。&lt;/p&gt;

&lt;p&gt;我的梦想又是什么呢？很简单，在自己所在的领域有所建树，然后把
这个领域的技术能够向前推动一点，哪怕只是一点。而这个简单的梦想，
仍需要很多的努力才能实现，我的希望是能够一直在这个努力的过程中，
不要因为其他的东西的干扰而偏离了梦想。&lt;/p&gt;

&lt;p&gt;而我差点因为微软的offer而偏离，极高的工资，舒适的工作环境，做的却
不是自己喜欢做的事。我明白，相对于其他在微软实习或者工作的人来说，
我还是相差太远。他们都是计算机竞赛的佼佼者，身上顶着各种光环，在计算机方面的积累比我
多了好几年，单就他们做过的题，我可能一辈子都来不及做完。我现在的学的东西也不是很扎实，
什么都知道一点，可都不精，如果再在微软待下去，或许就会沉浸在这种安逸的生活中，无法再
往一个更高的方向发展了。对于正值奋斗年华的我来说，过分的安乐真的不是什么好事。
而且在微软做的不是我喜欢做的事，要想突破感觉还是太难了。&lt;/p&gt;

&lt;p&gt;那为什么不把工作当成白天的事，然后空闲时间去做自己喜欢做的事呢？我也考虑过这个问题，
最后发现这很难成功。因为这样每天最多能花两个小时在自己喜欢做的事情上面，而同时可能会
有各种事情打乱你的计划，想对于正式工作的每天八小时，这其中的差距可想而知。在互联网这样一个
高速发展的行业，低速成长是很容易被淘汰的，这样的过程，最多持续半年，我想就会终止，然后渐渐地
开始沦落为毫无激情的上班族。能够通过用这种方式坚持的，至少在中国我还没有听说过。&lt;/p&gt;

&lt;p&gt;所以，我还需要很多的积累，扎实地磨练技术，同时更加开阔自己的眼界，而这些，通过研究生的三年，能够做到。&lt;/p&gt;

&lt;h2&gt;对自己目前的定位&lt;/h2&gt;

&lt;p&gt;总的来说，就是接触了很多的东西，但没有什么谈得上精通。&lt;/p&gt;

&lt;h3&gt;语言&lt;/h3&gt;

&lt;p&gt;语言确实用过很多，上过两个学期的C++课程，用C++写了数据结构的作业和USACO上的一些题，对于C++，应该算是最
熟悉的语言之一了吧，它的语法，还有很多相关的概念，包括虚函数，多态等等，都已经掌握了。可是不能算精通，对于它
的掌握仅仅局限于课堂，没用过STL,看过的书也就只有《C++ Primer》一本（教材除外），也没用它开发过大型的项目，对于
C++这样一门庞大的语言来说，这些还远远不够。&lt;/p&gt;

&lt;p&gt;关于C，也就用它写过操作系统的大作业，对于Unix环境下的C编程有一定的了解，现在如果要用C写一个大型的项目的话，
应该也没有什么问题，但如果要称得上是精通，还需要大量的练习才行。&lt;/p&gt;

&lt;p&gt;关于php，python，现在在上班的时候用得比较多，也正在处于一个水平稳步上升的阶段，我想经过一年的积累，这两门语言应该
是能够相当熟练，甚至是精通。&lt;/p&gt;

&lt;p&gt;关于javascript，CSS(如果它也算语言的话)，基本的语法也都知道，可是积累还远远不够，特别是javascript，这门上手容易，精通确
很难的语言，因为工作主要偏后端，所以熟练程度还是不够。&lt;/p&gt;

&lt;p&gt;关于C#，用它做过几个项目，用了WPF,ASP.NET，感觉C#这门语言还是比较容易上手的，写起代码来也很方便，配合上VS这个强大的IDE，
开发还是挺快的。我对它的了解还比较基础，至于它的反射，Delegation，Event等等东西，只是清楚概念，没有实际使用过。&lt;/p&gt;

&lt;p&gt;另外，我上过程序设计语言这门课程，在这门课程中，我接触了大量的语言，也用这些语言写过程序。
使用过Java，Perl,Scheme,Haskell,Prolog这些语言。值得一提的是，scheme和prolog我都写过好几个程序，
虽然这两门语言都比较奇怪，但是写程序时确实能够开阔思路，还是两门比较有趣的语言，我比较喜欢。&lt;/p&gt;

&lt;p&gt;对于“语言之争”，我没有特别的看法，我也没有特别的感觉说只用某一门语言或者只喜欢某一种语言。我觉得在不同的领域，
不同的场景，可能有些语言比另外一些语言要适合一些，比如说开发系统级别的应用程序，对执行效率要求比较高，这样，
C或者C++可能要适合一些，又比如一些做一些自动事情的脚本，可能python或者php用起来更加方便一些。每个语言都有它的
优点，对于语言我还是没有什么挑剔。&lt;/p&gt;

&lt;h3&gt;专业基础知识&lt;/h3&gt;

&lt;p&gt;对于专业知识，大部分都只限于课程，都是通过教材来了解，虽然这些教材都是国外的经典教材，
可是我觉得我们利用的还是太少了，大家都平时没怎么认真学习，然后到了考试，老师会给出几个
重点，然后大家根据这几个重点复习，应付考试而已。这些经典的教材，又岂是短短的这几天能够
掌握的？而我也不过是把这几天的时间分配到了整个学期而已，也就是说，我会跟着老师的上课进度，
把这些教材看一遍，看得有多深入，浅尝辄止罢了，粗粗地过完内容，然后总结一下了事。掌握得不是很扎实，
导致成绩也不是很好。专业基础课中，掌握得比较扎实的应该算操作系统和编译原理了吧，因为这两门课都做过
课程设计，多多少少需要了解一些东西。另外数据库也算把教材看得比较透彻的一门课，虽然考试成绩不咋的。&lt;/p&gt;

&lt;h3&gt;算法&lt;/h3&gt;

&lt;p&gt;只是知道常见几种算法:贪心法，分治法，动态规划。数据结构了解了：数，堆，哈希表，图，以及图的遍历，
最小生成树，最短路径。对于算法来说，和那些比较厉害的人的差距就在于：练习不够。别人能够做到各种算法
烂熟于胸，看到某类问题立刻想到相关的算法，因为什么，就是练习了那么多，一个问题做上10几遍，怎么能不熟。
所以在算法方面，我还得勤加练习，不然只能维持在现在的，看上去都会的水平。说现在找工作只看算法有点绝对，但
只要算法好想找任何工作是绝对没有问题的，各种经历告诉我这个观点的正确性。另外，在此提醒自己，《算法导论》
一定要坚持看完了，给自己下定一个决心吧。&lt;/p&gt;

&lt;h3&gt;技术之外&lt;/h3&gt;

&lt;p&gt;首先是表达能力有待增强，把自己清楚的东西讲到让别人也清楚这确实是一种艺术。写博客是一种很好的锻炼自己表达
能力的手段，所以我会经常把自己对技术的感悟通过写博客的方式表达出来，同时也分享了东西给大家。&lt;/p&gt;

&lt;p&gt;其次是提高英语的口语能力，多说，多听。&lt;/p&gt;

&lt;h2&gt;规划&lt;/h2&gt;

&lt;p&gt;在研究生的三年中，我需要达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行力：下定决心去做好每一件事&lt;/li&gt;
&lt;li&gt;了解自己研究方向：数据挖掘的方方面面，达到一个比较高的级别&lt;/li&gt;
&lt;li&gt;算法能力再提升一个档次，把算法从劣势转为优势&lt;/li&gt;
&lt;li&gt;对于大数据，云计算，虚拟化有比较深入的了解&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;目标并不多，也不是很远大，但仍然需要认真地去执行。&lt;/p&gt;

&lt;p&gt;另外，希望在这将近一年的实习生涯中达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;精通php,python&lt;/li&gt;
&lt;li&gt;对mysql性能优化有完整的理解和解决方案&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;前方路已经越发明朗了，接下来就是坚定地走下去。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ArchLinux 安装经过</title>
   <link href="http://username.github.com/linux/2012/09/14/archlinux-installation"/>
   <updated>2012-09-14T00:00:00+08:00</updated>
   <id>http://username.github.com/linux/2012/09/14/archlinux-installation</id>
   <content type="html">
&lt;p&gt;因为实在受不了Ubuntu的更新繁琐，终于还是下定决心安装ArchLinux了。虽说安装起来要比Ubuntu的无脑安装要艰辛许多，
可是成功之后的除了用起来爽很多之外，这其中的过程也是很有意义的。Arch的好处嘛，除了更新方便之外，源也比Ubuntu的
要快很多，社区服务用起来也比Ubuntu更加方便。废话不多说，直接说安装过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;当然首先是从arch的Download上下载iso文件，然后把它写到U盘中用于U盘引导安装，关于U盘引导，请参照&lt;a href=&quot;https://wiki.archlinux.org/index.php/USB_Installation_Media&quot;&gt;USB Installation Media&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我下的是2012.08.04的iso，刻录U盘的软件使用的是Linux Live USB Creator，上述页面中的其他的好像都不能正确引导，所以我还是推荐这个。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本安装&lt;/h2&gt;
&lt;p&gt;能够正确引导的话就可以进行安装了，安装的时候我完全是照着Wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/Beginners'_Guide&quot;&gt;Beginner&amp;#8217;s Guide&lt;/a&gt;一步步过来的。
只是有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为在开始安装基础包的时候需要网络链接，在网络连接的时候我采用的是static IP的有线连接，在设置网络的时候只需要正确设置有线连接即可。&lt;/li&gt;
  &lt;li&gt;在设置硬盘的时候一定要小心，一般情况下用于安装arch的硬盘已经排到了sda4以后，不要照着Beginner&amp;#8217;s Guide上面敲sda1等，稍不注意就会把windows给格掉。&lt;/li&gt;
  &lt;li&gt;在设置mirrorlist时，建议把China的几个server单独选出作为新的mirrorlist文件,这样比较稳定。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Configure BootLoader时，我用的是GRUB，同时要安装os-prober,这样能够自动检测其他系统然后会为这些系统建立引导项。命令也就几行:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  # pacman -S grub-bios
  # grub-install --target=i386-pc --recheck /dev/sda
  # cp /usr/share/locale/en\@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo
  # pacman -S os-prober
  # grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在注意以下几点之后，就能完成基本的安装了。能够有一个命令行下的基本archlinux系统了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;扩展安装&lt;/h2&gt;
&lt;p&gt;在完成基本安装之后，我安装了以下扩展。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;增加用户&lt;/h3&gt;
&lt;p&gt;这个只需要用&lt;code&gt;useradd&lt;/code&gt;命令即可。&lt;/p&gt;

&lt;h3 id=&quot;sudo&quot;&gt;安装sudo&lt;/h3&gt;
&lt;p&gt;通过pacman进行简单安装，然后通过visudo将需要的用户添加到sudolist中。&lt;/p&gt;

&lt;h3 id=&quot;gnome3&quot;&gt;安装Gnome3&lt;/h3&gt;
&lt;p&gt;首先是安装必备的几个包:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xorg-server xorg-xinit xorg-server-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装显卡驱动，我的显卡是nvida的，选用的驱动是nouveau：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xf86-video-nouveau
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装gnome,dbus,gdm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome, dbus, gdm 同时将dbus，gdm添加到/etc/rc.conf的daemons数组中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装gnome-tweak-tool用来调节gnome的主题和字体等:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome-tweak-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设置中文和字体&lt;/h3&gt;
&lt;p&gt;这个部分用来设置archlinux的中文支持和中文字体。&lt;/p&gt;

&lt;h4 id=&quot;locale&quot;&gt;设置locale&lt;/h4&gt;
&lt;p&gt;修改/etc/locale.gen文件，将以下行的注释去掉:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;en_US.UTF8 UTF-8
zh_CN.UTF8 UTF-8
zh_CN.GBK GBK
zh_CN.GB2312 GB2312
zh_CN.GB18030 GB18030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在/etc/rc.conf中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCALE=en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在~/.xprofile中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LANG=zh_CN.UTF-8
export LC_ALL=&quot;zh_CN.UTF-8&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;设置中文字体：&lt;/h4&gt;
&lt;p&gt;安装以下字体包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming ttf-fireflysung
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在gnome的高级设置中设置字体:我把所有的字体都设为文泉驿等宽正黑，这种字体中文和英文都比较圆滑。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;设置无线网络：&lt;/h3&gt;
&lt;p&gt;首先安装networkmanager，然后按照wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/NetworkManager&quot;&gt;NetWorkManager&lt;/a&gt;进行设置/etc/rc.conf。&lt;/p&gt;

&lt;p&gt;添加networkmanager到daemons数组，同时删除network。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DAEMONS=(syslog-ng crond dbus networkmanager sshd gdm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释interface那一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#interface=eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装network-manager-applet，这样就能在gnome启动的时候打开NetWorkManager，可以通过NetWorkManager管理无线网络和有线网络了，
就跟在Ubuntu中一样。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，我安装了我现在archlinux的主要部分，过程虽然比较复杂，但是只要照着wiki来，就能正确完成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://username.github.com/2012/09/13/hello-world"/>
   <updated>2012-09-13T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/09/13/hello-world</id>
   <content type="html">
&lt;p&gt;Github 真是个好东西，除了给你提供很好的代码托管服务，还提供了建立个人博客站点的功能。&lt;/p&gt;

&lt;p&gt;我这个博客就是通过Github Pages加上Jekyll创建的。&lt;/p&gt;

&lt;p&gt;想知道怎么回事？请看&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;Jekyll Quick Start&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有时间的话我就会来上面写写，感兴趣的话可以多来看看。我希望能够多谈谈自己所碰到的问题，以及是如何解决的，
借此来启发大家不要跟我犯同样的错误，也可以少走很多弯路。在这个博客中，只谈技术，不聊国事。&lt;/p&gt;

&lt;p&gt;好东西在天朝是不能存活下去的，github也不能幸免。我只希望我亲爱的祖国，能让我多用它一段时间，这样我也就满意了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://username.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://username.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, 
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately 
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;
  This is where the generated site will be placed once Jekyll is done transforming it. &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. 
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
Templates should be coded in HTML and contain YAML Front Matter. 
All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they 
define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files 
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data. &lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. 
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation.
What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template. &lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. 
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to 
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;
My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary
&lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files. &lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;  &lt;br /&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through 
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. 
The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one 
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;
 Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to 
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format 
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at []() 
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
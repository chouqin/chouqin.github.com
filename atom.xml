<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Chouqin & Laoqi</title>
 <link href="http://username.github.com/atom.xml" rel="self"/>
 <link href="http://username.github.com"/>
 <updated>2012-12-01T19:26:00+08:00</updated>
 <id>http://username.github.com</id>
 <author>
   <name>Qiping Li</name>
   <email>liqiping1991@gmail.com</email>
 </author>

 
 <entry>
   <title>算法导论8~9章读书笔记</title>
   <link href="http://username.github.com/clrs/2012/12/01/clrs-8-11"/>
   <updated>2012-12-01T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/12/01/clrs-8-11</id>
   <content type="html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;h3 id=&quot;section&quot;&gt;比较排序的时间下界&lt;/h3&gt;
&lt;p&gt;合并排序和堆排序在最坏情况下能够在O(nlgn)时间内排序n个数，
而快速排序则能够在平均情况下达到这个上界。
这些算法在确定元素的次序时，
都是基于元素间的比较。
这类排序算法称为&lt;strong&gt;比较排序&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比较排序的时间下界是O(nlgn)，
这意味着所有的基于比较的排序算法，在最坏情况下都要用&lt;script type=&quot;math/tex&quot;&gt; \Omega (n \lg n) &lt;/script&gt;
次比较来完成排序。&lt;/p&gt;

&lt;p&gt;这是因为比较排序可以被抽象为&lt;strong&gt;决策树&lt;/strong&gt;，
决策树是一棵满二叉数，
它的每一条从根节点到叶节点的路径都对应于比较排序的一次执行过程，
达到叶节点时，叶节点确定了这次排序的结果。
所以比较排序算法的最坏情况的比较次数等于决策树的高度。
n个数的排列总数有n!，每一种排列都必须在决策树的叶节点中出现，
高度为h的决策树的叶节点个数最多为&lt;script type=&quot;math/tex&quot;&gt; 2^h &lt;/script&gt;，故有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
n! \leq 2^h \\
\Longrightarrow   h \geq \lg (n!) = \Omega (n \lg n)
&lt;/script&gt;

&lt;p&gt;所以比较排序的时间下界是O(nlgn)。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通过计数排序实现线性时间排序&lt;/h3&gt;
&lt;p&gt;如果已经知道n个元素都是来自于0到k的整数，
其中&lt;script type=&quot;math/tex&quot;&gt; k = O(n) &lt;/script&gt;,
那么可以通过统计0到k中的每一个数在n个元素中出现的次数来达到排序的目的。
计数排序的运行时间为 &lt;script type=&quot;math/tex&quot;&gt; \Theta (n) &lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;书上在实现计数排序时，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先遍历一遍原数组A，将各个元素出现次数统计到数组C中,此时C[0..k]的每一项C[i]表示i在A中的出现次数&lt;/li&gt;
  &lt;li&gt;然后遍历一遍数组C, 使C[i]表示A中小于或等于i的元素个数&lt;/li&gt;
  &lt;li&gt;最后遍历A(逆向遍历)，把结果放到数组B中，把A[i]放到B的C[A[i]]位置上，同时把C[A[i]]减1
(这是为了把重复的元素放到不同的位置上去)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其实只需要让C[i]记录i在数组A中出现的次数，然后遍历一遍数组C就可以输出排序的结果。
具体遍历方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;j &amp;lt;- 1
for i &amp;lt;- 1 to k
    while C[i] &amp;gt; 0
        do C[i] &amp;lt;- C[i] - 1 
            A[j] = i
            j &amp;lt;- j + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就能把排序好的结果保存到A中，不需要另外的数组B。
但是书上的这种方法有一个好处，它能保证排序是&lt;strong&gt;稳定&lt;/strong&gt;的。
也就是说，具有相同值的元素在输出数组中的相对次序与输入数组中的相对次序一样。
因为是采取对A的逆向遍历，两个相同的元素中，位置靠前的元素后被遍历，此时C[i]已经变小了，
所以也会被放在更靠前的位置。稳定排序的好处在于它能够保证基数排序的正确性。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基数排序：另一种线性时间排序&lt;/h3&gt;
&lt;p&gt;基数排序主要解决的问题是对于多位整数的排序问题。
比如有n个d位数，每一位可以取k个不同的值，要对它进行排序，
一般的想法是先对最高位进行排序，
然后对于高位相同的子数组按次高位进行排序，依次类推。
这种想法的好处在于如果两个数中高位较大的数一定较大，
所以很容易把各个子数组的排序结果进行合并。比如排序10进制的三位数，
3XX一定都大于2XX，所以把2XX的子数组放在3XX的子数组前面就能保证合并结果的有序性。
但是它的不好的地方在于需要维护大量的子数组(随着递归的深度加深，子数组个数增多)，
这对于原始的基于纸带的排序的是不可行的。&lt;/p&gt;

&lt;p&gt;那有没有一种排序方法，既能使后面的排序利用到前面排序的结果，
而且能够不需要维护大量的子数组呢？基数排序就是这样一种排序方法，
它先把数组按最低位进行排序，然后再对结果按次低位进行排序，依次类推。
每一次的排序都必须是&lt;strong&gt;稳定排序&lt;/strong&gt;，这样能保证在按某位进行排序之后，
整个数组在从该位到最低位的子序列上都是有序的，可以通过一个简单的归纳加以证明。&lt;/p&gt;

&lt;p&gt;同时，在对n个b位数进行排序时，每次可以按r位进行排序，
而不仅仅是1位，这样能够在&lt;script type=&quot;math/tex&quot;&gt; \Omega ((b/r)(n + 2^r)) &lt;/script&gt;的时间内完成对数组的排序。
可以选取适当的r达到最好的时间性能。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;同时找出数组中的最大值和最小值&lt;/h3&gt;
&lt;p&gt;从一个数组中找出最大值或者最小值需要n-1次比较，
比如寻找最大值，首先将最大值设为第一个元素的值，
然后让n-1个元素和最大值进行比较，如果大于最大值，
就将最大值设为它，一共需要n-1次比较。&lt;/p&gt;

&lt;p&gt;而如果是同时找出最大值和最小值呢，
当然可以分别按上面的方法找出最大值和最小值，
一共需要的比较次数是2n-2。&lt;/p&gt;

&lt;p&gt;书上给出了另外一种方法：
成对的处理元素，将较小者与最小值相比，较大者与最大值相比，
这样能将比较次数降为&lt;script type=&quot;math/tex&quot;&gt;  3 \lceil n/2 \rceil &lt;/script&gt;。&lt;/p&gt;

&lt;h3 id=&quot;i&quot;&gt;在线性时间内选出数组中的第i小元素&lt;/h3&gt;
&lt;p&gt;书上给出了两种方法：&lt;/p&gt;

&lt;p&gt;第一种方法利用随机化快速排序算法中的RANDOMIZED-PARTITION函数对数组进行划分，然后根据
i是在哪一个部分中去相应部分中进行查找，这种方法能保证运行时间的期望是线性，代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def RANDOMIZED-SELECT(A, p, r, i)
    q &amp;lt;- RANDOMIZED-PARTITION(A, p, r)
    k &amp;lt;- q - p + 1
    if i = k
        then return A[q]
    elseif i &amp;lt; k
        then return RANDOMIZED-SELECT(A, p, q-1, i)
    else return RANDOMIZED-SELECT(A, q+1, r, i-k)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单说明一下在划分的两个子数组中，如果有一个长度为0，
为什么不会它调用RANDOMIZED-SELECT:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果子数组A[p..q-1]长度为0，则q = p，k = q - p + 1 = 1，&lt;script type=&quot;math/tex&quot;&gt; i \geq k &lt;/script&gt;, 不会对这个子数组调用RANDOMIZED-SELECT&lt;/li&gt;
  &lt;li&gt;如果子数组A[q+1..r]长度为0，则q = r，k = r - p + 1 = length[A]，&lt;script type=&quot;math/tex&quot;&gt; i \leq k &lt;/script&gt;, 不会对这个子数组调用RANDOMIZED-SELECT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二种方法通过保证每次的划分是一个好的划分保证算法的线性时间。
具体的划分方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将数组的n个元素划分为 &lt;script type=&quot;math/tex&quot;&gt; \lceil n/5 \rceil &lt;/script&gt;组，除最后一组之外，其余都有5个元素&lt;/li&gt;
  &lt;li&gt;对每一组找到其中位数, 首先对每个数组进行插入排序，然后找到其中的中位数&lt;/li&gt;
  &lt;li&gt;通过递归调用SELECT函数(就是找出数组中第i小元素的函数)，找到这些中位数中的中位数x&lt;/li&gt;
  &lt;li&gt;以x作为划分元素对数组进行划分&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个划分是一个好的划分，
因为能保证划分出来的两个子数组中任意一个的长度都不会超过某一个特定值。
在&lt;script type=&quot;math/tex&quot;&gt; \lceil n/5 \rceil &lt;/script&gt;个组中，
假设所有的中位数组成数组B[1..m]，其中 &lt;script type=&quot;math/tex&quot;&gt; m = \lceil n/5 \rceil &lt;/script&gt;,
假设x = B[k]，k = &lt;script type=&quot;math/tex&quot;&gt; \lceil \frac{1}{2} \lceil \frac{n}{5} \rceil \rceil &lt;/script&gt;,
在所有中位数在A[k..m]的组中，除去最后一组和x所在的组之外，其他的组至少有3个元素大于x，
所以大于x的元素个数至少为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
3(\lceil \frac{1}{2} \lceil \frac{n}{5} \rceil \rceil - 2) \geq \frac{3n}{10} - 6
&lt;/script&gt;

&lt;p&gt;类似的小于x的元素个数至少有&lt;script type=&quot;math/tex&quot;&gt; \frac{3n}{10} - 6 &lt;/script&gt;个，
所以至多有&lt;script type=&quot;math/tex&quot;&gt; \frac{7n}{10} + 6 &lt;/script&gt;个元素被递归的调用SELECT，
有了这个结论之后就能保证SELECT函数可以在线性的时间内完成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>《算法导论》读书总结1</title>
   <link href="http://username.github.com/clrs/2012/11/19/clrs-1"/>
   <updated>2012-11-19T00:00:00+08:00</updated>
   <id>http://username.github.com/clrs/2012/11/19/clrs-1</id>
   <content type="html">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;

&lt;p&gt;正如上一篇所说，我这几天都在学习《算法导论》这本书，
也终于是下定决心要好好把这本书看出个所以然来。
这几天看下来，发现最大的困扰并不是知识的难度，
而是克服自己内心的浮躁。因为这本书并不像其他的工科教材，
它讲得东西是比较偏理论一些，里面充满了各种数学公式，数学定理,
包括一个算法正确性的证明，都采取了形式化的证明手段，
力求证明的数学严格性。
如果只是需要粗粗理解各种算法是什么样的以及如何实现的话，
那么看这本书有点不太合适，
因为这方面的东西并不是这本书的重点。&lt;/p&gt;

&lt;p&gt;而我，也是在粗粗了解了各种算法和实现的基础上学习这本书的，
一开始扫了一下书的第一章，第二章和第六章，
发现和其他的算法书还差不多嘛，
直到看到第七章快速排序，
看到作者在大概描述完快速排序算法之后
（这个快速排序的划分函数还和我以前见过的都不一样，更加容易理解和实现），
转而开始分析快速排序的性能和随机化版本，我才明白，
我不能再这么浮躁地只是抱着了解了解算法的目的来学习这本书了。
于是我又回过去仔仔细细地从头看到了第7章，
虽然说这本书里的定理和数学公式很多，但是并不难理解，
因为作者总是把每一个步骤解释地十分细致和透彻，
每一步的证明没有很大的跨越，
每一个结论的得出都会指明依据的定理或者是前面的结论。
所以说好好看下去其实并没有很大难度，
关键是要能够静得下心。&lt;/p&gt;

&lt;p&gt;下面是1～7章中我的几点体会：&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;section&quot;&gt;循环不变式&lt;/h3&gt;
&lt;p&gt;循环不变式用于证明算法的正确性，
它能够保证一个算法能够终止，
而且当它终止时，得到的结果是正确的结果。
循环不变式的证明由三个部分组成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化: 在循环的开始时，循环不变式成立。&lt;/li&gt;
  &lt;li&gt;保持：如果在某一轮迭代之前循环不变式成立，那么在迭代之后，
循环不变式仍然成立。&lt;/li&gt;
  &lt;li&gt;终止：如果保持循环不变式一直到循环的终止，那么这个算法将得到正确的结果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;循环不变式与数学归纳法十分类似，采用的也是同样的思想。
在应用循环不变式对算法的正确性进行证明时，
难点不在于上述的三个步骤，而在于循环不变式的构造，
要构造一个循环不变式能够在循环过程中始终保持，
而且能体现算法正确性，这确实需要一定的技巧。
这就类似于在应用数学归纳法时选取归纳条件。&lt;/p&gt;

&lt;p&gt;比如书中思考题2-2：（证明冒泡排序的正确性）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i &amp;lt;- 1 to length[A]
    do for j &amp;lt;- length[A] downto i+1
        do if A[j] &amp;lt; A[j-1]
            then exchange A[j] &amp;lt;-&amp;gt; A[j-1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b)对于2-4行(内层循环)给出一个循环不变式，并证明这个循环不变式是成立的。&lt;/p&gt;

&lt;p&gt;内层循环的作用是把A[i]到A[n]（n是length[A]）中最小元素放到A[i],
可以采用如下的循环不变式来表示：&lt;/p&gt;

&lt;p&gt;在每一轮迭代的开始，子数组A[j..n]中最小的元素位于A[j]。&lt;/p&gt;

&lt;p&gt;下面对这个循环不变式进行证明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;初始化： 在第一轮迭代开始前，j = n，A[j..n]中就只有一个元素，
最小的元素位于A[n]。&lt;/li&gt;
  &lt;li&gt;保持：在第k轮迭代时，
    &lt;ul&gt;
      &lt;li&gt;如果A[j] &amp;gt;= A[j-1]，由循环不变式可知，
A[j]是字数组A[j..n]中最小的元素，那么循环结束时A[j-1]将是字数组A[j-1..n]中的最小元素。&lt;/li&gt;
      &lt;li&gt;如果A[j] &amp;lt; A[j-1], 那么在互换A[j]和A[j-1]之后，最小的元素仍然是A[j-1]。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;终止: 在循环结束时j=i, 说明A[i]是字数组A[i..n]中的最小元素，
算法达到了把最小元素放到A[i]的目的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-1&quot;&gt;渐进符号&lt;/h3&gt;
&lt;p&gt;渐进符号用户描述一个算法的复杂度，以前只知道
渐进符号用于描述算法的量级，比如&lt;script type=&quot;math/tex&quot;&gt; 2n^2 = O(n^2) &lt;/script&gt; 
说明 
&lt;script type=&quot;math/tex&quot;&gt; 2n^2 &lt;/script&gt;
的量级是
&lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;。&lt;/p&gt;

&lt;p&gt;书上给出了准确的定义:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
O(g(n)) = \{f(n): \exists c,n， \forall n \geq n_0,  0 \leq f(n) \leq cg(n)\}
&lt;/script&gt;

&lt;p&gt;同时有：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
f(n) = O(g(n)) \Longleftrightarrow f(n) \in O(g(n)) 
&lt;/script&gt;

&lt;p&gt;其他的符号如&lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\Theta &lt;/script&gt;都是类似的定义。
当然，我们只需要知道用&lt;script type=&quot;math/tex&quot;&gt; O(f(n)) &lt;/script&gt;来确定一个函数的上界，
用&lt;script type=&quot;math/tex&quot;&gt; \Omega(f(n)) &lt;/script&gt;来确定一个函数的下界就可以了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;递归与主定理&lt;/h3&gt;
&lt;p&gt;分治法是一种很常见的算法设计方法，
分治法的时间复杂度一般由如下的递归式给出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
T(n) = aT(n/b) + f(n)
&lt;/script&gt;

&lt;p&gt;其中&lt;script type=&quot;math/tex&quot;&gt; a \geq 1, b &gt; 1&lt;/script&gt;，f(n)一般用渐进函数表示。&lt;/p&gt;

&lt;p&gt;对于这样的递归式，主定理给出了计算T(n)的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果存在常数&lt;script type=&quot;math/tex&quot;&gt; \epsilon &gt; 0 &lt;/script&gt;，有
&lt;script type=&quot;math/tex&quot;&gt; f(n) = O(n^{\log_ba - \epsilon}) &lt;/script&gt;，
则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(n^{\log_ba}) &lt;/script&gt;;&lt;/li&gt;
  &lt;li&gt;如果
&lt;script type=&quot;math/tex&quot;&gt; f(n) = \Theta(n^{\log_ba}) &lt;/script&gt;，
则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(n^{\log_ba}\lg n) &lt;/script&gt;;&lt;/li&gt;
  &lt;li&gt;如果存在常数&lt;script type=&quot;math/tex&quot;&gt; \epsilon &gt; 0 &lt;/script&gt;，有
&lt;script type=&quot;math/tex&quot;&gt; f(n) = \Omega(n^{\log_ba + \epsilon}) &lt;/script&gt;，
且对常数&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
 c &lt; 1  %]]&gt;&lt;/script&gt;与足够大的n,有
&lt;script type=&quot;math/tex&quot;&gt; af(n/b) \leq cf(n) &lt;/script&gt;，则
&lt;script type=&quot;math/tex&quot;&gt; T(n) = \Theta(f(n)) &lt;/script&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运用主定理，能够很快地求出分治算法的复杂度。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;指示器随机变量&lt;/h3&gt;
&lt;p&gt;指示器随机变量的定义如下:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
 
    X_H = I\{H\} = 
     \begin{cases}
         1 &amp; \text{如果H发生} \\
         0 &amp; \text{如果H没有发生}
     \end{cases}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;指示器随机变量是随机变量的一种，可以求出它的期望如下：
$$
    E[X_H] = Pr_H
$$&lt;/p&gt;

&lt;p&gt;指示器随机变量有一个很好的性质，它只能取0或者1，
可以把它这些变量加起来求总的发生次数,
因此当它应用到重复随机试验中时,
统计重复试验某一事件发生次数的期望，
比如在随机化的快速排序中统计交换次数的期望,
可以通过如下公式得到：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; 
E[X] = E[\sum_{i=1}^n X_i] = \sum_{i=1}^n E[X_i]
&lt;/script&gt;

&lt;p&gt;要使等式的第二步成立，不一定要保证&lt;script type=&quot;math/tex&quot;&gt; X_i &lt;/script&gt;之间是相互独立的。&lt;/p&gt;

&lt;p&gt;这周的读书笔记就先写到这里，下周开始写第8章开始的内容。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL 基本优化</title>
   <link href="http://username.github.com/mysql/2012/11/15/mysql-basic"/>
   <updated>2012-11-15T00:00:00+08:00</updated>
   <id>http://username.github.com/mysql/2012/11/15/mysql-basic</id>
   <content type="html">
&lt;p&gt;这几天好好地研究了一下mysql,认真地看了《High Performance MySQL》的几章，
才发现，要能够精通mysql真的是一个长期的工程，有效地管理mysql,
使它能够具有很强的稳定性同时具有很快的相应速度，
这其中涉及的东西远远不是数据库的课上写几条sql语句那么简单。
而在这篇博客中，我也仅就mysql的一些基本优化知识谈谈我的看法，
待以后更加深入研究之后，再继续分享。&lt;/p&gt;

&lt;h2 id=&quot;mysql&quot;&gt;MySQL的表的设计&lt;/h2&gt;

&lt;h3 id=&quot;normalized-schema-or-denormalized-schema&quot;&gt;Normalized Schema Or Denormalized Schema?&lt;/h3&gt;
&lt;p&gt;在一般的数据库教材中，讲到设计库表结构的设计，
都是将数据库设计范式作为设计的准则，因为这样设计的数据库表重复很少，
这样就会减少存储空间，
同时因为重复的内容少，维护起来也很方便，
因为如果很多的重复的话一个信息的更改可能会需要在多处进行更改才能保证数据的一致性。
然而，数据库范式并不是万能的，这样设计出来的数据库会造成查找时间的加长，
因为要查找一些数据往往需要将多个表join起来，而join是比较费时间的数据库操作，
同时，一些有关系的列被分散到各个表中，不好组合在一起建成一个索引，
这样也会减低查找的速度。
所以在设计数据库的表的结构时，要结合应用的实际情况，平衡考虑。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;cache-table--summary-table&quot;&gt;Cache Table &amp;amp; Summary Table&lt;/h3&gt;
&lt;p&gt;使用“空间换取时间”的理念，在数据统计的过程中，为了方便同时，
我们会建立一些缓存表，
这些表的目的是把一个表中的多行信息或者多个表的信息综合起来，
比如有一个表保存了今天的用户访问记录，
就可以建成一个daycount表统计每天有多少用户访问，
这样如果需要查询某一天有多少用户访问的时候直接去这个表中去查了。
缓存表引入的一个问题是缓存表的维护，
一般是通过一些周期性跑的脚本去更新这些缓存表，
FlexView这个工具能够自动的帮我们维护这些缓存表，
有兴趣的可以尝试一下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;数据类型的选择&lt;/h3&gt;
&lt;p&gt;尽量选择小的，简单的数据类型，能用tinyint就不要用int,能有enum就不要用varchar。
同时尽量不要用NULL，因为NULL会引入许多的问题，首先是它不容易被索引，
同时保存它占用了更多的空间。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;索引优化总结&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;为什么索引能够提高查找的速度？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;索引能够减少需要数据库需要读取的数据。因为它不需要整个表都读取一遍，
同时如果使用了覆盖索引，那么需要的数据就在索引中，只要将索引的数据返回即可。&lt;/li&gt;
  &lt;li&gt;索引能够帮助数据库进行排序。如果要排序的字段刚好在索引中，
由于索引本身就是排好序的，这样就不需要再进行排序，减少了时间和空间的浪费。&lt;/li&gt;
  &lt;li&gt;索引能够把随机IO转化为顺序IO，这是因为索引靠近的数据一般存储的位置也是相邻的，
这样能够顺序读取。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;多字段索引时顺序的选择&lt;/h3&gt;
&lt;p&gt;有时，建立索引一个字段的索引往往就够用了，因为通过这一个字段，就能过滤掉大部分的行，
剩下来的行数比较少，这样再进行过滤或者是sort, group等操作都不会有很大的压力。
然而，如果表中的数据非常多，一个字段过滤之后可能数据还是非常多，
这时就需要建立一个多字段的索引，又称为组合索引。&lt;/p&gt;

&lt;p&gt;组合索引的顺序选择非常重要，因为mysql只能拿一个索引的前缀进行索引。比如有一个索引
(col1, col2)，那么如果你的where语句中col1 = a and col2 = b或者是col1 = a，
这时mysql可以使用这个索引。但如果你的where语句是col2 = b这时就不能使用这个索引。
另外一个关乎索引顺序的地方是如果你的过滤条件是一个范围(range condition)的时候，再拿上面的索引为例，
如果你where语句有col1 = 1 and col2 &amp;lt; 2时，两个过滤的条件都会在使用索引过滤的时候起到作用，
而如果where语句是col1 &amp;gt; 1 and col2 = 2，这时只有第一个过滤条件在过滤索引时起到作用，也就是说，
在这时存储引擎会把col1 &amp;gt; 1的所有行都返回到mysql server，
而后服务器再通过col2 = 2过滤掉一些行，这个过滤的效果显然不好，
特别是当数据量较大的时候。关于这个的详细解释，
可以参考这篇&lt;a href=&quot;http://jorgenloland.blogspot.sg/2011/08/mysql-range-access-method-explained.html&quot;&gt;The MySQL range access method explained&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;既然索引的顺序这么重要，那如何去设计列的顺序呢？我总结了一些我的看法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A Rule of Thumb: 选择最具有过滤性列的放在索引的前面，因为这样的列能够很快地过滤掉
一些不需要的行。&lt;/li&gt;
  &lt;li&gt;把最经常拿来过滤的字段放在索引的前面，因为mysql使用的是前缀索引，
如果不经常使用的列放在前面会造成索引的失效。&lt;/li&gt;
  &lt;li&gt;把那些比较容易使用范围来进行过滤的字段放在索引后面，比如说day, created_at什么的。
因为如果这些字段放在前面会造成后面字段的过滤条件不起作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;explain&quot;&gt;理解explain语句&lt;/h3&gt;
&lt;p&gt;要知道一个索引设计得好不好，它有没有在sql语句中被合理地使用，
通过explain sql来查看sql一些执行细节是很有必要的。
explain sql的输出结果中，除了包含索引选择等信息，
还会告诉你诸如mysql如何对结果进行排序等信息。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://weevilgenius.net/2010/09/mysql-explain-reference/&quot;&gt;MySQL Explain – Reference&lt;/a&gt;
这篇博客详细地讲述了explain语句输出的各个字段表示的意义，
特别是将type(access type)这个部分讲得特别清楚。&lt;/p&gt;

&lt;h2 id=&quot;sql&quot;&gt;优化SQL语句&lt;/h2&gt;
&lt;p&gt;设计好表的结构和索引之后，仍然需要采取适当的方式来进行查询才能达到更好的执行效率。
《High Performance MySQL》给出了几个优化的技巧：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尽量使用join来代替子查询语句，因为它能够更好地利用索引。&lt;/li&gt;
  &lt;li&gt;使用&amp;#8217;deferred join&amp;#8217;来优化limit offset,具体可参照《High Performance MySQL》的6.7.5节。&lt;/li&gt;
  &lt;li&gt;优化join:
    &lt;ul&gt;
      &lt;li&gt;确保被join的字段在第二个表中被索引&lt;/li&gt;
      &lt;li&gt;确保group by或者order by的字段在同一个表中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-4&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://net.tutsplus.com/tutorials/other/top-20-mysql-best-practices/&quot;&gt;Top 20+ MySQL Best Practices&lt;/a&gt;，
陈皓写了这篇的&lt;a href=&quot;http://coolshell.cn/articles/1846.html&quot;&gt;翻译版&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://isky000.com/database/mysql-performance-tuning-index&quot;&gt;MySQl 性能优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-5&quot;&gt;预告&lt;/h2&gt;
&lt;p&gt;前两天&lt;a href=&quot;http://weibo.com/jeffz&quot;&gt;@老赵&lt;/a&gt;发起了一个资助大学生读书的计划，
我有幸得到了他资助的《算法导论》一本。
这样一本书并不是随便就能得来的，正如老赵所说：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;因此，千万不要把这个计划当做是免费的图书来源，选书要谨慎，拿到书就要好好阅读。
在我看来，参与这个计划其实更多的是压力。
当然，有适当的压力对于学习也是很有好处的，不是么？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而我，也正是需要这样的一种压力，能够督促我更好地去学习这样一本经典教材。
因此，接下来我会经常地在这里公布我的读书笔记，更多的是自己学习算法的心得体会，
希望能够多多有所感悟，学到更多的东西。:)&lt;/p&gt;

&lt;p&gt;特别感谢老赵的热心，能够让我们阅读这些经典的书籍，也希望他能够帮助更多的人。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浅谈中文编码</title>
   <link href="http://username.github.com/python/2012/11/11/chinese-encoding"/>
   <updated>2012-11-11T00:00:00+08:00</updated>
   <id>http://username.github.com/python/2012/11/11/chinese-encoding</id>
   <content type="html">
&lt;p&gt;作为一个天朝的程序员，总是会在编程的时候与中文打交道。一开始对于编码不是很熟悉，也没有弄明白它里面的原理，
在处理中文的时候总是会遇到各种各样的问题，特别是在用python处理中文的时候，
所以特地花时间研究了一下中文编码，并通过python来熟悉一些概念。&lt;/p&gt;

&lt;p&gt;废话不多说，先上干货，&lt;a href=&quot;http://www.searchtb.com/2012/04/chinese_encode.html&quot;&gt;中文编码杂谈&lt;/a&gt;，
这篇文章是淘宝搜索技术团队写的，深入浅出，基本上将中文编码的各个方面讲得十分细致，而且十分通俗易懂。
我很难讲得比这篇文章更好了，我主要从几个侧面来阐述一下我对于中文编码的理解。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;中文编码是什么&lt;/h2&gt;
&lt;p&gt;中文编码其实就是将中文转化为二进制比特串的过程，而不同的编码方式会把同一个中文字符转化为不同的二进制表示，
比如“中”这个字，通过utf-8编码会转化为二进制E4B8AD，而在计算机中，所有的数据都是通过二进制保存，这样我们就可以
通过二进制E4B8AD来保存“中”字，然后我们如果需要读取保存的这个字，我们首先需要知道编码方式是utf-8，然后就能将
E4B8AD转化为“中”。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;python的中文处理&lt;/h2&gt;
&lt;p&gt;python提供了对unicode很好的支持，同时也能将unicode转化为其他的各种编码。&lt;/p&gt;

&lt;p&gt;下面通过代码来对解释一下pytho中的编码问题。&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;我是123&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xe6\x88\x91\xe6\x98\xaf&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;!--more--&gt;

&lt;p&gt;从上面的代码可以看到，python把&amp;#8221;我是123&amp;#8221;这个字符串当成是str类型，其实只是把这个字符串的编码
二进制当成中文来处理。当我们通过输入法输入&amp;#8221;我是123&amp;#8221;时，输入法会根据我们系统的LACALE值将&amp;#8221;我是123&amp;#8221;
编码成相应的二进制，而python遇到二进制值时的处理也是要根据系统的编码方式，如果是一个python的脚本，
我们可以通过再脚本的头部通过&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;`# -*- coding:utf-8 -*- `
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置python处理编码的方式。&lt;/p&gt;

&lt;p&gt;同时可以看到&amp;#8221;我是123&amp;#8221;这个字符串的长度是9，这是因为字符串a在utf8编码时的二进制表示为&lt;code&gt;'\xe6\x88\x91\xe6\x98\xaf\x21\x22\x23'&lt;/code&gt;,
一共占了9个字节，python的len()函数对于字符串就是计算它占了多少个byte,所以:len(a) = 9。&lt;/p&gt;

&lt;p&gt;下面看如何与unicode进行相互转化:(此时采用的编码是utf8，其他的编码也是一样的处理):&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;u&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\u6211\u662f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;我是&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;123&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;unicode&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xe6\x88\x91\xe6\x98\xaf&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;123&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将字符串转换为unicode通过decode()函数，反过来通过encode()函数。同时也可以通过：&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;unicode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;我是123&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者是&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;ua&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;u&amp;quot;我是123&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到同样的unicode。可以看到ua的长度为5，因为在unicode中不管是汉字还是字母或者是数字，
都当作同样的字符来进行处理，这样一个unicode的长度就是所有字符的个数，而不管这些字符是中文
汉字还是英文字符。这样的好处就在于能够很好地定位到一个具体的字符，字符串的截取以及正则表达式
匹配等操作都十分方便。所以推荐在处理包含中文的字符串时，先把这个字符串转化为unicode，然后再
进行操作，操作完以后再encode成字符串。&lt;/p&gt;

&lt;p&gt;关于中文编码就很浅显地谈到这里，希望能给大家带来帮助，有什么问题可以在留言中和我讨论。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>最近的总结与感悟</title>
   <link href="http://username.github.com/Feelings/2012/10/27/feeling"/>
   <updated>2012-10-27T00:00:00+08:00</updated>
   <id>http://username.github.com/Feelings/2012/10/27/feeling</id>
   <content type="html">

&lt;h2&gt;来由&lt;/h2&gt;

&lt;p&gt;这段时间真的很忙，忙得都没时间好好看书，好好写博客。&lt;/p&gt;

&lt;p&gt;每天都要上班，还要忙着保研的各种事情，有时还在保研和直接工作中纠结，
导致一有一点空闲时间，就什么事情也没想干了。&lt;/p&gt;

&lt;p&gt;还好，现在这些事情也终于告一段落，也不用再去纠结什么了，终于可以静下心来
去做自己喜欢做的事，踏踏实实地学习某些东西了。&lt;/p&gt;

&lt;p&gt;但是总结一番还是有点必要的，不然这些日子的纠结不是白费了吗。&lt;/p&gt;

&lt;!--more--&gt;


&lt;h2&gt;我为什么选择读研&lt;/h2&gt;

&lt;p&gt;其实这个星期的前两天还在纠结当中，可是就好像砸中牛顿的那个苹果一样，
某种东西突然在我的头脑中闪现，让我顿悟，这个东西就是：梦想。&lt;/p&gt;

&lt;p&gt;梦想，别扯淡了，这年头谁还看中这个。&lt;/p&gt;

&lt;p&gt;我看中，我认为一个人一旦失去了梦想，活着也就没有什么意思了。
能支持一个人不断向前，不断超越自己的动力，也只有梦想。&lt;/p&gt;

&lt;p&gt;我的梦想又是什么呢？很简单，在自己所在的领域有所建树，然后把
这个领域的技术能够向前推动一点，哪怕只是一点。而这个简单的梦想，
仍需要很多的努力才能实现，我的希望是能够一直在这个努力的过程中，
不要因为其他的东西的干扰而偏离了梦想。&lt;/p&gt;

&lt;p&gt;而我差点因为微软的offer而偏离，极高的工资，舒适的工作环境，做的却
不是自己喜欢做的事。我明白，相对于其他在微软实习或者工作的人来说，
我还是相差太远。他们都是计算机竞赛的佼佼者，身上顶着各种光环，在计算机方面的积累比我
多了好几年，单就他们做过的题，我可能一辈子都来不及做完。我现在的学的东西也不是很扎实，
什么都知道一点，可都不精，如果再在微软待下去，或许就会沉浸在这种安逸的生活中，无法再
往一个更高的方向发展了。对于正值奋斗年华的我来说，过分的安乐真的不是什么好事。
而且在微软做的不是我喜欢做的事，要想突破感觉还是太难了。&lt;/p&gt;

&lt;p&gt;那为什么不把工作当成白天的事，然后空闲时间去做自己喜欢做的事呢？我也考虑过这个问题，
最后发现这很难成功。因为这样每天最多能花两个小时在自己喜欢做的事情上面，而同时可能会
有各种事情打乱你的计划，想对于正式工作的每天八小时，这其中的差距可想而知。在互联网这样一个
高速发展的行业，低速成长是很容易被淘汰的，这样的过程，最多持续半年，我想就会终止，然后渐渐地
开始沦落为毫无激情的上班族。能够通过用这种方式坚持的，至少在中国我还没有听说过。&lt;/p&gt;

&lt;p&gt;所以，我还需要很多的积累，扎实地磨练技术，同时更加开阔自己的眼界，而这些，通过研究生的三年，能够做到。&lt;/p&gt;

&lt;h2&gt;对自己目前的定位&lt;/h2&gt;

&lt;p&gt;总的来说，就是接触了很多的东西，但没有什么谈得上精通。&lt;/p&gt;

&lt;h3&gt;语言&lt;/h3&gt;

&lt;p&gt;语言确实用过很多，上过两个学期的C++课程，用C++写了数据结构的作业和USACO上的一些题，对于C++，应该算是最
熟悉的语言之一了吧，它的语法，还有很多相关的概念，包括虚函数，多态等等，都已经掌握了。可是不能算精通，对于它
的掌握仅仅局限于课堂，没用过STL,看过的书也就只有《C++ Primer》一本（教材除外），也没用它开发过大型的项目，对于
C++这样一门庞大的语言来说，这些还远远不够。&lt;/p&gt;

&lt;p&gt;关于C，也就用它写过操作系统的大作业，对于Unix环境下的C编程有一定的了解，现在如果要用C写一个大型的项目的话，
应该也没有什么问题，但如果要称得上是精通，还需要大量的练习才行。&lt;/p&gt;

&lt;p&gt;关于php，python，现在在上班的时候用得比较多，也正在处于一个水平稳步上升的阶段，我想经过一年的积累，这两门语言应该
是能够相当熟练，甚至是精通。&lt;/p&gt;

&lt;p&gt;关于javascript，CSS(如果它也算语言的话)，基本的语法也都知道，可是积累还远远不够，特别是javascript，这门上手容易，精通确
很难的语言，因为工作主要偏后端，所以熟练程度还是不够。&lt;/p&gt;

&lt;p&gt;关于C#，用它做过几个项目，用了WPF,ASP.NET，感觉C#这门语言还是比较容易上手的，写起代码来也很方便，配合上VS这个强大的IDE，
开发还是挺快的。我对它的了解还比较基础，至于它的反射，Delegation，Event等等东西，只是清楚概念，没有实际使用过。&lt;/p&gt;

&lt;p&gt;另外，我上过程序设计语言这门课程，在这门课程中，我接触了大量的语言，也用这些语言写过程序。
使用过Java，Perl,Scheme,Haskell,Prolog这些语言。值得一提的是，scheme和prolog我都写过好几个程序，
虽然这两门语言都比较奇怪，但是写程序时确实能够开阔思路，还是两门比较有趣的语言，我比较喜欢。&lt;/p&gt;

&lt;p&gt;对于“语言之争”，我没有特别的看法，我也没有特别的感觉说只用某一门语言或者只喜欢某一种语言。我觉得在不同的领域，
不同的场景，可能有些语言比另外一些语言要适合一些，比如说开发系统级别的应用程序，对执行效率要求比较高，这样，
C或者C++可能要适合一些，又比如一些做一些自动事情的脚本，可能python或者php用起来更加方便一些。每个语言都有它的
优点，对于语言我还是没有什么挑剔。&lt;/p&gt;

&lt;h3&gt;专业基础知识&lt;/h3&gt;

&lt;p&gt;对于专业知识，大部分都只限于课程，都是通过教材来了解，虽然这些教材都是国外的经典教材，
可是我觉得我们利用的还是太少了，大家都平时没怎么认真学习，然后到了考试，老师会给出几个
重点，然后大家根据这几个重点复习，应付考试而已。这些经典的教材，又岂是短短的这几天能够
掌握的？而我也不过是把这几天的时间分配到了整个学期而已，也就是说，我会跟着老师的上课进度，
把这些教材看一遍，看得有多深入，浅尝辄止罢了，粗粗地过完内容，然后总结一下了事。掌握得不是很扎实，
导致成绩也不是很好。专业基础课中，掌握得比较扎实的应该算操作系统和编译原理了吧，因为这两门课都做过
课程设计，多多少少需要了解一些东西。另外数据库也算把教材看得比较透彻的一门课，虽然考试成绩不咋的。&lt;/p&gt;

&lt;h3&gt;算法&lt;/h3&gt;

&lt;p&gt;只是知道常见几种算法:贪心法，分治法，动态规划。数据结构了解了：数，堆，哈希表，图，以及图的遍历，
最小生成树，最短路径。对于算法来说，和那些比较厉害的人的差距就在于：练习不够。别人能够做到各种算法
烂熟于胸，看到某类问题立刻想到相关的算法，因为什么，就是练习了那么多，一个问题做上10几遍，怎么能不熟。
所以在算法方面，我还得勤加练习，不然只能维持在现在的，看上去都会的水平。说现在找工作只看算法有点绝对，但
只要算法好想找任何工作是绝对没有问题的，各种经历告诉我这个观点的正确性。另外，在此提醒自己，《算法导论》
一定要坚持看完了，给自己下定一个决心吧。&lt;/p&gt;

&lt;h3&gt;技术之外&lt;/h3&gt;

&lt;p&gt;首先是表达能力有待增强，把自己清楚的东西讲到让别人也清楚这确实是一种艺术。写博客是一种很好的锻炼自己表达
能力的手段，所以我会经常把自己对技术的感悟通过写博客的方式表达出来，同时也分享了东西给大家。&lt;/p&gt;

&lt;p&gt;其次是提高英语的口语能力，多说，多听。&lt;/p&gt;

&lt;h2&gt;规划&lt;/h2&gt;

&lt;p&gt;在研究生的三年中，我需要达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行力：下定决心去做好每一件事&lt;/li&gt;
&lt;li&gt;了解自己研究方向：数据挖掘的方方面面，达到一个比较高的级别&lt;/li&gt;
&lt;li&gt;算法能力再提升一个档次，把算法从劣势转为优势&lt;/li&gt;
&lt;li&gt;对于大数据，云计算，虚拟化有比较深入的了解&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;目标并不多，也不是很远大，但仍然需要认真地去执行。&lt;/p&gt;

&lt;p&gt;另外，希望在这将近一年的实习生涯中达到下面的目标：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;精通php,python&lt;/li&gt;
&lt;li&gt;对mysql性能优化有完整的理解和解决方案&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;结语&lt;/h2&gt;

&lt;p&gt;前方路已经越发明朗了，接下来就是坚定地走下去。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ArchLinux 安装经过</title>
   <link href="http://username.github.com/linux/2012/09/14/archlinux-installation"/>
   <updated>2012-09-14T00:00:00+08:00</updated>
   <id>http://username.github.com/linux/2012/09/14/archlinux-installation</id>
   <content type="html">
&lt;p&gt;因为实在受不了Ubuntu的更新繁琐，终于还是下定决心安装ArchLinux了。虽说安装起来要比Ubuntu的无脑安装要艰辛许多，
可是成功之后的除了用起来爽很多之外，这其中的过程也是很有意义的。Arch的好处嘛，除了更新方便之外，源也比Ubuntu的
要快很多，社区服务用起来也比Ubuntu更加方便。废话不多说，直接说安装过程。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;当然首先是从arch的Download上下载iso文件，然后把它写到U盘中用于U盘引导安装，关于U盘引导，请参照&lt;a href=&quot;https://wiki.archlinux.org/index.php/USB_Installation_Media&quot;&gt;USB Installation Media&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我下的是2012.08.04的iso，刻录U盘的软件使用的是Linux Live USB Creator，上述页面中的其他的好像都不能正确引导，所以我还是推荐这个。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section-1&quot;&gt;基本安装&lt;/h2&gt;
&lt;p&gt;能够正确引导的话就可以进行安装了，安装的时候我完全是照着Wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/Beginners'_Guide&quot;&gt;Beginner&amp;#8217;s Guide&lt;/a&gt;一步步过来的。
只是有几点需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;因为在开始安装基础包的时候需要网络链接，在网络连接的时候我采用的是static IP的有线连接，在设置网络的时候只需要正确设置有线连接即可。&lt;/li&gt;
  &lt;li&gt;在设置硬盘的时候一定要小心，一般情况下用于安装arch的硬盘已经排到了sda4以后，不要照着Beginner&amp;#8217;s Guide上面敲sda1等，稍不注意就会把windows给格掉。&lt;/li&gt;
  &lt;li&gt;在设置mirrorlist时，建议把China的几个server单独选出作为新的mirrorlist文件,这样比较稳定。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Configure BootLoader时，我用的是GRUB，同时要安装os-prober,这样能够自动检测其他系统然后会为这些系统建立引导项。命令也就几行:&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  # pacman -S grub-bios
  # grub-install --target=i386-pc --recheck /dev/sda
  # cp /usr/share/locale/en\@quot/LC_MESSAGES/grub.mo /boot/grub/locale/en.mo
  # pacman -S os-prober
  # grub-mkconfig -o /boot/grub/grub.cfg
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在注意以下几点之后，就能完成基本的安装了。能够有一个命令行下的基本archlinux系统了。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;扩展安装&lt;/h2&gt;
&lt;p&gt;在完成基本安装之后，我安装了以下扩展。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;增加用户&lt;/h3&gt;
&lt;p&gt;这个只需要用&lt;code&gt;useradd&lt;/code&gt;命令即可。&lt;/p&gt;

&lt;h3 id=&quot;sudo&quot;&gt;安装sudo&lt;/h3&gt;
&lt;p&gt;通过pacman进行简单安装，然后通过visudo将需要的用户添加到sudolist中。&lt;/p&gt;

&lt;h3 id=&quot;gnome3&quot;&gt;安装Gnome3&lt;/h3&gt;
&lt;p&gt;首先是安装必备的几个包:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xorg-server xorg-xinit xorg-server-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装显卡驱动，我的显卡是nvida的，选用的驱动是nouveau：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S xf86-video-nouveau
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装gnome,dbus,gdm:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome, dbus, gdm 同时将dbus，gdm添加到/etc/rc.conf的daemons数组中。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装gnome-tweak-tool用来调节gnome的主题和字体等:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S gnome-tweak-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;设置中文和字体&lt;/h3&gt;
&lt;p&gt;这个部分用来设置archlinux的中文支持和中文字体。&lt;/p&gt;

&lt;h4 id=&quot;locale&quot;&gt;设置locale&lt;/h4&gt;
&lt;p&gt;修改/etc/locale.gen文件，将以下行的注释去掉:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;en_US.UTF8 UTF-8
zh_CN.UTF8 UTF-8
zh_CN.GBK GBK
zh_CN.GB2312 GB2312
zh_CN.GB18030 GB18030
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同时在/etc/rc.conf中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;LOCALE=en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在~/.xprofile中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export LANG=zh_CN.UTF-8
export LC_ALL=&quot;zh_CN.UTF-8&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-5&quot;&gt;设置中文字体：&lt;/h4&gt;
&lt;p&gt;安装以下字体包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# pacman -S wqy-bitmapfont wqy-zenhei ttf-arphic-ukai ttf-arphic-uming ttf-fireflysung
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在gnome的高级设置中设置字体:我把所有的字体都设为文泉驿等宽正黑，这种字体中文和英文都比较圆滑。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;设置无线网络：&lt;/h3&gt;
&lt;p&gt;首先安装networkmanager，然后按照wiki上的&lt;a href=&quot;https://wiki.archlinux.org/index.php/NetworkManager&quot;&gt;NetWorkManager&lt;/a&gt;进行设置/etc/rc.conf。&lt;/p&gt;

&lt;p&gt;添加networkmanager到daemons数组，同时删除network。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DAEMONS=(syslog-ng crond dbus networkmanager sshd gdm)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释interface那一行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#interface=eth0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后安装network-manager-applet，这样就能在gnome启动的时候打开NetWorkManager，可以通过NetWorkManager管理无线网络和有线网络了，
就跟在Ubuntu中一样。&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，我安装了我现在archlinux的主要部分，过程虽然比较复杂，但是只要照着wiki来，就能正确完成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://username.github.com/2012/09/13/hello-world"/>
   <updated>2012-09-13T00:00:00+08:00</updated>
   <id>http://username.github.com/2012/09/13/hello-world</id>
   <content type="html">
&lt;p&gt;Github 真是个好东西，除了给你提供很好的代码托管服务，还提供了建立个人博客站点的功能。&lt;/p&gt;

&lt;p&gt;我这个博客就是通过Github Pages加上Jekyll创建的。&lt;/p&gt;

&lt;p&gt;想知道怎么回事？请看&lt;a href=&quot;http://jekyllbootstrap.com/usage/jekyll-quick-start.html&quot;&gt;Jekyll Quick Start&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有时间的话我就会来上面写写，感兴趣的话可以多来看看。我希望能够多谈谈自己所碰到的问题，以及是如何解决的，
借此来启发大家不要跟我犯同样的错误，也可以少走很多弯路。在这个博客中，只谈技术，不聊国事。&lt;/p&gt;

&lt;p&gt;好东西在天朝是不能存活下去的，github也不能幸免。我只希望我亲爱的祖国，能让我多用它一段时间，这样我也就满意了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jekyll Introduction</title>
   <link href="http://username.github.com/lessons/2011/12/29/jekyll-introduction"/>
   <updated>2011-12-29T00:00:00+08:00</updated>
   <id>http://username.github.com/lessons/2011/12/29/jekyll-introduction</id>
   <content type="html">
&lt;p&gt;This Jekyll introduction will outline specifically  what Jekyll is and why you would want to use it.
Directly following the intro we&amp;#8217;ll learn exactly &lt;em&gt;how&lt;/em&gt; Jekyll does what it does.&lt;/p&gt;

&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;/h2&gt;

&lt;h3 id=&quot;what-is-jekyll&quot;&gt;What is Jekyll?&lt;/h3&gt;

&lt;p&gt;Jekyll is a parsing engine bundled as a ruby gem used to build static websites from
dynamic components such as templates, partials, liquid code, markdown, etc. Jekyll is known as &amp;#8220;a simple, blog aware, static site generator&amp;#8221;.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;This website is created with Jekyll. &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Sites&quot;&gt;Other Jekyll websites&lt;/a&gt;.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;what-does-jekyll-do&quot;&gt;What does Jekyll Do?&lt;/h3&gt;

&lt;p&gt;Jekyll is a ruby gem you install on your local system.
Once there you can call &lt;code&gt;jekyll --server&lt;/code&gt; on a directory and provided that directory
is setup in a way jekyll expects, it will do magic stuff like parse markdown/textile files, 
compute categories, tags, permalinks, and construct your pages from layout templates and partials.&lt;/p&gt;

&lt;p&gt;Once parsed, Jekyll stores the result in a self-contained static &lt;code&gt;_site&lt;/code&gt; folder.
The intention here is that you can serve all contents in this folder statically from a plain static web-server.&lt;/p&gt;

&lt;p&gt;You can think of Jekyll as a normalish dynamic blog but rather than parsing content, templates, and tags
on each request, Jekyll does this once &lt;em&gt;beforehand&lt;/em&gt; and caches the &lt;em&gt;entire website&lt;/em&gt; in a folder for serving statically.&lt;/p&gt;

&lt;h3 id=&quot;jekyll-is-not-blogging-software&quot;&gt;Jekyll is Not Blogging Software&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Jekyll is a parsing engine.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Jekyll does not come with any content nor does it have any templates or design elements.
This is a common source of confusion when getting started.
Jekyll does not come with anything you actually use or see on your website - you have to make it.&lt;/p&gt;

&lt;h3 id=&quot;why-should-i-care&quot;&gt;Why Should I Care?&lt;/h3&gt;

&lt;p&gt;Jekyll is very minimalistic and very efficient.
The most important thing to realize about Jekyll is that it creates a static representation of your website requiring only a static web-server.
Traditional dynamic blogs like Wordpress require a database and server-side code.
Heavily trafficked dynamic blogs must employ a caching layer that ultimately performs the same job Jekyll sets out to do; serve static content.&lt;/p&gt;

&lt;p&gt;Therefore if you like to keep things simple and you prefer the command-line over an admin panel UI then give Jekyll a try.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Developers like Jekyll because we can write content like we write code:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Ability to write content in markdown or textile in your favorite text-editor.&lt;/li&gt;
  &lt;li&gt;Ability to write and preview your content via localhost.&lt;/li&gt;
  &lt;li&gt;No internet connection required.&lt;/li&gt;
  &lt;li&gt;Ability to publish via git.&lt;/li&gt;
  &lt;li&gt;Ability to host your blog on a static web-server.&lt;/li&gt;
  &lt;li&gt;Ability to host freely on GitHub Pages.&lt;/li&gt;
  &lt;li&gt;No database required.&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;how-jekyll-works&quot;&gt;How Jekyll Works&lt;/h1&gt;

&lt;p&gt;The following is a complete but concise outline of exactly how Jekyll works.&lt;/p&gt;

&lt;p&gt;Be aware that core concepts are introduced in rapid succession without code examples.
This information is not intended to specifically teach you how to do anything, rather it
is intended to give you the &lt;em&gt;full picture&lt;/em&gt; relative to what is going on in Jekyll-world.&lt;/p&gt;

&lt;p&gt;Learning these core concepts should help you avoid common frustrations and ultimately 
help you better understand the code examples contained throughout Jekyll-Bootstrap.&lt;/p&gt;

&lt;h2 id=&quot;initial-setup&quot;&gt;Initial Setup&lt;/h2&gt;

&lt;p&gt;After &lt;a href=&quot;/index.html#start-now&quot;&gt;installing jekyll&lt;/a&gt; you&amp;#8217;ll need to format your website directory in a way jekyll expects.
Jekyll-bootstrap conveniently provides the base directory format.&lt;/p&gt;

&lt;h3 id=&quot;the-jekyll-application-base-format&quot;&gt;The Jekyll Application Base Format&lt;/h3&gt;

&lt;p&gt;Jekyll expects your website directory to be laid out like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.markdown
|   |-- 20011-04-26-hello-world.markdown
|-- _site
|-- index.html
|-- assets
    |-- css
        |-- style.css
    |-- javascripts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_config.yml&lt;/strong&gt;&lt;br /&gt;
  Stores configuration data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_includes&lt;/strong&gt;&lt;br /&gt;
  This folder is for partial views.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_layouts&lt;/strong&gt; &lt;br /&gt;
  This folder is for the main templates your content will be inserted into.
  You can have different layouts for different pages or page sections.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_posts&lt;/strong&gt;&lt;br /&gt;
  This folder contains your dynamic content/posts.
  the naming format is required to be &lt;code&gt;@YEAR-MONTH-DATE-title.MARKUP@&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;_site&lt;/strong&gt;&lt;br /&gt;
  This is where the generated site will be placed once Jekyll is done transforming it. &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;assets&lt;/strong&gt;&lt;br /&gt;
  This folder is not part of the standard jekyll structure.
  The assets folder represents &lt;em&gt;any generic&lt;/em&gt; folder you happen to create in your root directory.
  Directories and files not properly formatted for jekyll will be left untouched for you to serve normally.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(read more: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Usage&quot;&gt;https://github.com/mojombo/jekyll/wiki/Usage&lt;/a&gt;)&lt;/p&gt;

&lt;h3 id=&quot;jekyll-configuration&quot;&gt;Jekyll Configuration&lt;/h3&gt;

&lt;p&gt;Jekyll supports various configuration options that are fully outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;https://github.com/mojombo/jekyll/wiki/Configuration&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;content-in-jekyll&quot;&gt;Content in Jekyll&lt;/h2&gt;

&lt;p&gt;Content in Jekyll is either a post or a page.
These content &amp;#8220;objects&amp;#8221; get inserted into one or more templates to build the final output for its respective static-page.&lt;/p&gt;

&lt;h3 id=&quot;posts-and-pages&quot;&gt;Posts and Pages&lt;/h3&gt;

&lt;p&gt;Both posts and pages should be written in markdown, textile, or HTML and may also contain Liquid templating syntax.
Both posts and pages can have meta-data assigned on a per-page basis such as title, url path, as well as arbitrary custom meta-data.&lt;/p&gt;

&lt;h3 id=&quot;working-with-posts&quot;&gt;Working With Posts&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Post&lt;/strong&gt; &lt;br /&gt;
Posts are created by properly formatting a file and placing it the &lt;code&gt;_posts&lt;/code&gt; folder.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
A post must have a valid filename in the form &lt;code&gt;YEAR-MONTH-DATE-title.MARKUP&lt;/code&gt; and be placed in the &lt;code&gt;_posts&lt;/code&gt; directory. 
If the data format is invalid Jekyll will not recognize the file as a post. The date and title are automatically parsed from the filename of the post file.
Additionally, each file must have &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt; prepended to its content.
YAML Front-Matter is a valid YAML syntax specifying meta-data for the given file.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Order&lt;/strong&gt;&lt;br /&gt;
Ordering is an important part of Jekyll but it is hard to specify a custom ordering strategy.
Only reverse chronological and chronological ordering is supported in Jekyll.&lt;/p&gt;

&lt;p&gt;Since the date is hard-coded into the filename format, to change the order, you must change the dates in the filenames.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tags&lt;/strong&gt; &lt;br /&gt;
Posts can have tags associated with them as part of their meta-data.
Tags may be placed on posts by providing them in the post&amp;#8217;s YAML front matter.
You have access to the post-specific tags in the templates. These tags also get added to the sitewide collection.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories&lt;/strong&gt; &lt;br /&gt;
Posts may be categorized by providing one or more categories in the YAML front matter.
Categories offer more significance over tags in that they can be reflected in the URL path to the given post.
Note categories in Jekyll work in a specific way.
If you define more than one category you are defining a category hierarchy &amp;#8220;set&amp;#8221;.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title :  Hello World
categories : [lessons, beginner]
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This defines the category hierarchy &amp;#8220;lessons/beginner&amp;#8221;. Note this is &lt;em&gt;one category&lt;/em&gt; node in Jekyll.
You won&amp;#8217;t find &amp;#8220;lessons&amp;#8221; and &amp;#8220;beginner&amp;#8221; as two separate categories unless you define them elsewhere as singular categories.&lt;/p&gt;

&lt;h3 id=&quot;working-with-pages&quot;&gt;Working With Pages&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Creating a Page&lt;/strong&gt;&lt;br /&gt;
Pages are created by properly formatting a file and placing it anywhere in the root directory or subdirectories that do &lt;em&gt;not&lt;/em&gt; start with an underscore.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
In order to register as a Jekyll page the file must contain &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;YAML Front-Matter&lt;/a&gt;.
Registering a page means 1) that Jekyll will process the page and 2) that the page object will be available in the &lt;code&gt;site.pages&lt;/code&gt; array for inclusion into your templates.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Categories and Tags&lt;/strong&gt;&lt;br /&gt;
Pages do not compute categories nor tags so defining them will have no effect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sub-Directories&lt;/strong&gt;&lt;br /&gt;
If pages are defined in sub-directories, the path to the page will be reflected in the url.
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
|-- people
    |-- bob
        |-- essay.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This page will be available at &lt;code&gt;http://yourdomain.com/people/bob/essay.html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recommended Pages&lt;/strong&gt;  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;index.html&lt;/strong&gt;&lt;br /&gt;
You will always want to define the root index.html page as this will display on your root URL.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;404.html&lt;/strong&gt;&lt;br /&gt;
Create a root 404.html page and GitHub Pages will serve it as your 404 response.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;sitemap.html&lt;/strong&gt;&lt;br /&gt;
Generating a sitemap is good practice for SEO.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;about.html&lt;/strong&gt;&lt;br /&gt;
A nice about page is easy to do and gives the human perspective to your website.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;templates-in-jekyll&quot;&gt;Templates in Jekyll&lt;/h2&gt;

&lt;p&gt;Templates are used to contain a page&amp;#8217;s or post&amp;#8217;s content.
All templates have access to a global site object variable: &lt;code&gt;site&lt;/code&gt; as well as a page object variable: &lt;code&gt;page&lt;/code&gt;.
The site variable holds all accessible content and metadata relative to the site.
The page variable holds accessible data for the given page or post being rendered at that point.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Create a Template&lt;/strong&gt;&lt;br /&gt;
Templates are created by properly formatting a file and placing it in the &lt;code&gt;_layouts&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Formatting&lt;/strong&gt;&lt;br /&gt;
Templates should be coded in HTML and contain YAML Front Matter. 
All templates can contain Liquid code to work with your site&amp;#8217;s data.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Rending Page/Post Content in a Template&lt;/strong&gt;&lt;br /&gt;
There is a special variable in all templates named : &lt;code&gt;content&lt;/code&gt;.
The &lt;code&gt;content&lt;/code&gt; variable holds the page/post content including any sub-template content previously defined.
Render the content variable wherever you want your main content to be injected into your template:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
&amp;lt;body&amp;gt;
  &amp;lt;div id=&quot;sidebar&quot;&amp;gt; ... &amp;lt;/div&amp;gt;
  &amp;lt;div id=&quot;main&quot;&amp;gt;
    &amp;#123;{content}&amp;#125;
  &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
...&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;sub-templates&quot;&gt;Sub-Templates&lt;/h3&gt;

&lt;p&gt;Sub-templates are exactly templates with the only difference being they 
define another &amp;#8220;root&amp;#8221; layout/template within their YAML Front Matter.
This essentially means a template will render inside of another template.&lt;/p&gt;

&lt;h3 id=&quot;includes&quot;&gt;Includes&lt;/h3&gt;
&lt;p&gt;In Jekyll you can define include files by placing them in the &lt;code&gt;_includes&lt;/code&gt; folder.
Includes are NOT templates, rather they are just code snippets that get included into templates.
In this way, you can treat the code inside includes as if it was native to the parent template.&lt;/p&gt;

&lt;p&gt;Any valid template code may be used in includes.&lt;/p&gt;

&lt;h2 id=&quot;using-liquid-for-templating&quot;&gt;Using Liquid for Templating&lt;/h2&gt;

&lt;p&gt;Templating is perhaps the most confusing and frustrating part of Jekyll.
This is mainly due to the fact that Jekyll templates must use the Liquid Templating Language.&lt;/p&gt;

&lt;h3 id=&quot;what-is-liquid&quot;&gt;What is Liquid?&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Shopify/liquid&quot;&gt;Liquid&lt;/a&gt; is a secure templating language developed by &lt;a href=&quot;http://shopify.com&quot;&gt;Shopify&lt;/a&gt;.
Liquid is designed for end-users to be able to execute logic within template files 
without imposing any security risk on the hosting server.&lt;/p&gt;

&lt;p&gt;Jekyll uses Liquid to generate the post content within the final page layout structure and as the primary interface for working with
your site and post/page data. &lt;/p&gt;

&lt;h3 id=&quot;why-do-we-have-to-use-liquid&quot;&gt;Why Do We Have to Use Liquid?&lt;/h3&gt;

&lt;p&gt;GitHub uses Jekyll to power &lt;a href=&quot;http://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. 
GitHub cannot afford to run arbitrary code on their servers so they lock developers down via Liquid.&lt;/p&gt;

&lt;h3 id=&quot;liquid-is-not-programmer-friendly&quot;&gt;Liquid is Not Programmer-Friendly.&lt;/h3&gt;

&lt;p&gt;The short story is liquid is not real code and its not intended to execute real code.
The point being you can&amp;#8217;t do jackshit in liquid that hasn&amp;#8217;t been allowed explicitly by the implementation.
What&amp;#8217;s more you can only access data-structures that have been explicitly passed to the template. &lt;/p&gt;

&lt;p&gt;In Jekyll&amp;#8217;s case it is not possible to alter what is passed to Liquid without hacking the gem or running custom plugins. 
Both of which cannot be supported by GitHub Pages.&lt;/p&gt;

&lt;p&gt;As a programmer - this is very frustrating.&lt;/p&gt;

&lt;p&gt;But rather than look a gift horse in the mouth we are going to 
suck it up and view it as an opportunity to work around limitations and adopt client-side solutions when possible.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Aside&lt;/strong&gt; &lt;br /&gt;
My personal stance is to not invest time trying to hack liquid. It&amp;#8217;s really unnecessary
&lt;em&gt;from a programmer&amp;#8217;s&lt;/em&gt; perspective. That is to say if you have the ability to run custom plugins (i.e. run arbitrary ruby code)
you are better off sticking with ruby. Toward that end I&amp;#8217;ve built &lt;a href=&quot;http://github.com/plusjade/mustache-with-jekyll&quot;&gt;Mustache-with-Jekyll&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-assets&quot;&gt;Static Assets&lt;/h2&gt;

&lt;p&gt;Static assets are any file in the root or non-underscored subfolders that are not pages.
That is they have no valid YAML Front Matter and are thus not treated as Jekyll Pages.&lt;/p&gt;

&lt;p&gt;Static assets should be used for images, css, and javascript files. &lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-parses-files&quot;&gt;How Jekyll Parses Files&lt;/h2&gt;

&lt;p&gt;Remember Jekyll is a processing engine. There are two main types of parsing in Jekyll.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Content parsing.&lt;/strong&gt; &lt;br /&gt;
  This is done with textile or markdown.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template parsing.&lt;/strong&gt; &lt;br /&gt;
This is done with the liquid templating language.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And thus there are two main types of file formats needed for this parsing.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Post and Page files.&lt;/strong&gt;&lt;br /&gt;
All content in Jekyll is either a post or a page so valid posts and pages are parsed with markdown or textile.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Template files.&lt;/strong&gt;  &lt;br /&gt;
  These files go in &lt;code&gt;_layouts&lt;/code&gt; folder and contain your blogs &lt;strong&gt;templates&lt;/strong&gt;. They should be made in HTML with the help of Liquid syntax.
  Since include files are simply injected into templates they are essentially parsed as if they were native to the template.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Arbitrary files and folders.&lt;/strong&gt; &lt;br /&gt;
Files that &lt;em&gt;are not&lt;/em&gt; valid pages are treated as static content and pass through 
Jekyll untouched and reside on your blog in the exact structure and format they originally existed in.&lt;/p&gt;

&lt;h3 id=&quot;formatting-files-for-parsing&quot;&gt;Formatting Files for Parsing.&lt;/h3&gt;

&lt;p&gt;We&amp;#8217;ve outlined the need for valid formatting using &lt;strong&gt;YAML Front Matter&lt;/strong&gt;.
Templates, posts, and pages all need to provide valid YAML Front Matter even if the Matter is empty.
This is the only way Jekyll knows you want the file processed.&lt;/p&gt;

&lt;p&gt;YAML Front Matter must be prepended to the top of template/post/page files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
layout: post
category : pages
tags : [how-to, jekyll]
---

... contents ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Three hyphens on a new line start the Front-Matter block and three hyphens on a new line end the block.
The data inside the block must be valid YAML.&lt;/p&gt;

&lt;p&gt;Configuration parameters for YAML Front-Matter is outlined here:
&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/YAML-Front-Matter&quot;&gt;A comprehensive explanation of YAML Front Matter&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;defining-layouts-for-posts-and-templates-parsing&quot;&gt;Defining Layouts for Posts and Templates Parsing.&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; parameter in the YAML Front Matter defines the template file for which the given post or template should be injected into.
If a template file specifies its own layout, it is effectively being used as a &lt;code&gt;sub-template.&lt;/code&gt;
That is to say loading a post file into a template file that refers to another template file with work in the way you&amp;#8217;d expect; as a nested sub-template.&lt;/p&gt;

&lt;h2 id=&quot;how-jekyll-generates-the-final-static-files&quot;&gt;How Jekyll Generates the Final Static Files.&lt;/h2&gt;

&lt;p&gt;Ultimately, Jekyll&amp;#8217;s job is to generate a static representation of your website. 
The following is an outline of how that&amp;#8217;s done:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll collects data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll scans the posts directory and collects all posts files as post objects. It then scans the layout assets and collects those and finally scans other directories in search of pages.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll computes data.&lt;/strong&gt; &lt;br /&gt;
  Jekyll takes these objects, computes metadata (permalinks, tags, categories, titles, dates) from them and constructs one 
  big &lt;code&gt;site&lt;/code&gt; object that holds all the posts, pages, layouts, and respective metadata.
  At this stage your site is one big computed ruby object.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll liquifies posts and templates.&lt;/strong&gt;&lt;br /&gt;
  Next jekyll loops through each post file and converts (through markdown or textile) and &lt;strong&gt;liquifies&lt;/strong&gt; the post inside of its respective layout(s).
  Once the post is parsed and liquified inside the the proper layout structure, the layout itself is &amp;#8220;liquified&amp;#8221;. &lt;br /&gt;
 &lt;strong&gt;Liquification&lt;/strong&gt; is defined as follows: Jekyll initiates a Liquid template, and passes a simpler hash representation of the ruby site object as well as a simpler
  hash representation of the ruby post object. These simplified data structures are what you have access to in the templates.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Jekyll generates output.&lt;/strong&gt; &lt;br /&gt;
 Finally the liquid templates are &amp;#8220;rendered&amp;#8221;, thereby processing any liquid syntax provided in the templates
 and saving the final, static representation of the file.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Notes.&lt;/strong&gt;&lt;br /&gt;
Because Jekyll computes the entire site in one fell swoop, each template is given access to 
a global &lt;code&gt;site&lt;/code&gt; hash that contains useful data. It is this data that you&amp;#8217;ll iterate through and format 
using the Liquid tags and filters in order to render it onto a given page.&lt;/p&gt;

&lt;p&gt;Remember, in Jekyll you are an end-user. Your API has only two components:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The manner in which you setup your directory.&lt;/li&gt;
  &lt;li&gt;The liquid syntax and variables passed into the liquid templates.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;All the data objects available to you in the templates via Liquid are outlined in the &lt;strong&gt;API Section&lt;/strong&gt; of Jekyll-Bootstrap.
You can also read the original documentation here: &lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Template-Data&quot;&gt;https://github.com/mojombo/jekyll/wiki/Template-Data&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I hope this paints a clearer picture of what Jekyll is doing and why it works the way it does.
As noted, our main programming constraint is the fact that our API is limited to what is accessible via Liquid and Liquid only.&lt;/p&gt;

&lt;p&gt;Jekyll-bootstrap is intended to provide helper methods and strategies aimed at making it more intuitive and easier to work with Jekyll =)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Thank you&lt;/strong&gt; for reading this far.&lt;/p&gt;

&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;

&lt;p&gt;Please take a look at []() 
or jump right into &lt;a href=&quot;&quot;&gt;Usage&lt;/a&gt; if you&amp;#8217;d like.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>